<script>
// DEBUG: Log and highlight the topmost element at the pointer position on click/tap
// window.addEventListener('click', function(e) {
//   const el = document.elementFromPoint(e.clientX, e.clientY);
//   if (el) {
//     console.log('Clicked element:', el, 'id:', el.id, 'class:', el.className);
//     // Add a red outline for 1s
//     el.style.outline = '3px solid red';
//     setTimeout(() => { el.style.outline = ''; }, 1000);
//   } else {
//     console.log('No element found at click position');
//   }
// }, true);
window.addEventListener('DOMContentLoaded', () => {
  const debugShowNotification = document.getElementById('debugShowNotification');
  if (debugShowNotification) {
    debugShowNotification.addEventListener('click', ()=>{
      const debugDropdown = document.getElementById('debugDropdown');
      if (debugDropdown) debugDropdown.style.display = 'none';
      showAssistNotification('Test notification: This should be flush left!');
    });
  }
});
</script>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Card Combat</title>
  <script src="slash-attack.js"></script>
    <style>
      :root {
        --cabinet-height: 8vh; /* 8% of viewport height */
        --cards-height: 30vh; /* default cards height on mobile */
        --safe: env(safe-area-inset-bottom, 0px);
        --bg: radial-gradient(1200px 800px at 50% 10%, #0f172a 0%, #020617 45%, #000000 100%);
        --accent: #ef4444; /* red */
        --text: #e5e7eb;
        --muted: #94a3b8;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        background: var(--bg);
        touch-action: manipulation; /* reduce mobile click delay and ghost scrolling */
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        font-size: 1.5rem; /* reduce global fonts by ~25% from previous */
        display: grid;
        grid-template-rows: auto 1fr var(--cabinet-height);
        grid-template-columns: 100%;
      }
      /* Top progress bar */
      header.progress-wrap {
        display: grid;
        place-items: center;
        padding-top: 8px;
        padding-bottom: 8px;
        position: relative; /* allow overlay positioning */
      }
      .progress-outer {
        position: relative;
        display: block;
        width: 90%;
        max-width: 500px;
        margin: 0 auto; /* center horizontally */
      }
      .progress {
        position: relative;
        width: calc(100% - 36px); /* reserve space for badge */
        margin-left: 36px;
        height: 32px; /* doubled height */
        border-radius: 999px;
        background: rgba(148,163,184,0.25);
        overflow: hidden;
      }
      /* Level badge to the left of the bar */
      #levelBadge {
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-size: 0.78rem;
        font-weight: 800;
        color: #0f172a;
        background: radial-gradient(circle at 35% 35%, #c7d2fe 0%, #93c5fd 55%, #60a5fa 100%);
        border: 2px solid rgba(255,255,255,0.65);
        box-shadow: 0 4px 10px rgba(2,6,23,0.35);
        pointer-events: none;
      }
      .progress .fill {
        position: absolute;
        left: 0; top: 0; bottom: 0;
        width: 0%;
        background: linear-gradient(90deg, #22c55e, #16a34a);
        transition: width 300ms ease; /* animate progress change for visibility */
      }
      .progress .label {
        position: absolute;
        left: 0; right: 0; top: 50%; transform: translateY(-50%);
        text-align: center;
        /* Match mobile's darker, bolder look across breakpoints */
        font-size: 0.9rem;
        color: #064e3b; /* dark green for high contrast */
        font-weight: 900;
        mix-blend-mode: screen;
      }
      /* Jackpot overlay under the progress bar without affecting layout */
      #jackpot {
        position: absolute;
        top: 44px; /* progress height (32) + header padding (~12) */
        left: 50%;
        transform: translateX(-50%);
        pointer-events: none;
        /* Unify font size and weight across mobile/desktop */
        font-weight: 900;
        font-size: clamp(1rem, 2.8vw, 1.25rem);
        color: #facc15;
        text-shadow: 0 1px 2px rgba(0,0,0,0.45);
      }
      #game {
        position: relative;
        overflow: hidden;
      }
      /* Monster area: fills the space between the top (below progress bar) and the character band */
      #monsterArea {
        position: absolute;
        left: 0; right: 0;
        top: 0;
        bottom: calc(var(--cabinet-height) + var(--cards-height) + 10vh); /* leave room for cards + character band */
        display: grid;
        /* Anchor content to the top, centered horizontally */
        place-items: start center;
        z-index: 0; /* under character and effects */
        pointer-events: auto; /* allow overlay button interactions */
      }
      /* Wrapper to anchor and scale the monster from the top */
      #monsterSpriteWrap {
        transform-origin: top center;
        pointer-events: none; /* let buttons be clickable */
        display: grid;
        place-items: center;
      }
      #monsterArea img {
        max-width: min(90%, 520px);
        /* Reduce height a touch and add bottom clearance so it never crowds the player band */
        max-height: 84%;
        margin-bottom: clamp(10px, 3vh, 40px);
        width: auto;
        height: auto;
        object-fit: contain;
        filter: drop-shadow(0 10px 24px rgba(0,0,0,0.5));
        pointer-events: none; /* image itself not clickable */
        display: block;
        margin-left: auto;
        margin-right: auto;
      }
  /* Mobile: grow ~15% from previous (0.75 -> ~0.8625) and keep top anchor so growth is downward */
  #monsterSpriteWrap { transform: translateY(5%) scale(0.8625); }
      /* Desktop: keep the monster a bit narrower and maintain comfortable gap above players */
      @media (min-width: 768px) {
        /* Desktop: center monster vertically/horizontally */
        #monsterArea { place-items: center; }
        #monsterArea img {
          /* Prioritise vertical fit between jackpot and player band */
          max-width: min(80%, 680px);
          max-height: 90%;
          /* Remove bottom margin so true centering isn't biased */
          margin: 0;
        }
        /* Desktop: grow ~15% from previous scale (1.06 -> ~1.219) with top anchor so growth is downward */
        #monsterSpriteWrap {
          transform-origin: top center;
          transform: translateY(3%) scale(1.219);
        }
      }
      /* Corner buttons (stats/debug/help) */
      .cornerBtn, .helpBtn {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 1px solid rgba(148,163,184,0.35);
        background: rgba(2,6,23,0.7);
        color: #e5e7eb;
        display: grid;
        place-items: center;
        cursor: pointer;
        z-index: 2;
        box-shadow: 0 6px 14px rgba(0,0,0,0.35);
      }
      .helpBtn {
        left: 12px;
        right: auto;
        width: 44px;
        height: 44px;
        font-size: 1.5rem;
        font-weight: 900;
        background: rgba(2,6,23,0.85);
        color: #facc15;
        border: 2px solid #facc15;
        box-shadow: 0 6px 18px rgba(250,204,21,0.12);
      }
      .cornerBtn:active { transform: translateY(1px); }
      .cornerBtn svg { width: 22px; height: 22px; opacity: 0.9; }
      /* Debug button stacks under stats with small offset */
  #debugBtn { top: 58px; }
  /* Remove static top for debugBtn, will be set dynamically */
  #debugDropdownWrap { position: absolute !important; right: 12px; z-index: 12; display: inline-block; left: unset !important; }
      /* Character area (10% height) above the cards */
      #characterArea {
        position: absolute;
        left: 0; right: 0;
        bottom: calc(var(--cabinet-height) + var(--cards-height));
        height: 10vh;
        pointer-events: auto;
        background: rgba(2, 6, 23, 0.66);
        border-top: 1px solid rgba(148, 163, 184, 0.2);
        border-bottom: 1px solid rgba(148, 163, 184, 0.15);
        box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25), inset 0 6px 12px rgba(0,0,0,0.15);
        z-index: 1;
      }
      /* Generic player unit container */
      .playerUnit {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        bottom: 4px; /* sit near bottom of the band */
        transform: translateX(-50%);
        transition: left 220ms ease-out;
      }
      /* Maintain existing id for local player */
  #player { position: absolute; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; bottom: 4px; transform: translateX(-50%); transition: left 220ms ease-out; }
      #playerRect {
        width: 20px; /* fixed player width */
        height: 60px; /* fixed player height */
        background: #38bdf8; /* sky blue */
        border: 2px solid rgba(255,255,255,0.65);
        border-radius: 4px;
        box-shadow: 0 4px 8px rgba(2,6,23,0.35);
      }
      .playerRect { width: 20px; height: 60px; background: #64748b; border: 2px solid rgba(255,255,255,0.65); border-radius: 4px; box-shadow: 0 4px 8px rgba(2,6,23,0.35); }
      /* Player damage flash */
      #playerRect.hit { animation: player-hit 250ms ease; }
      @keyframes player-hit { 0%{filter:brightness(1)} 50%{filter:brightness(1.8)} 100%{filter:brightness(1)} }
      /* HP badge shown over each player */
      .hpBadge {
        position: absolute;
        top: -14px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.78rem;
        font-weight: 800;
        color: #e5e7eb;
        background: rgba(2,6,23,0.7);
        border: 1px solid rgba(148,163,184,0.35);
        border-radius: 999px;
        padding: 2px 8px;
        z-index: 2;
        white-space: nowrap;
      }
      .playerName {
        margin-top: 4px;
        font-size: 0.8rem;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(0,0,0,0.45);
      }
      /* Effects overlay */
      #effects {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 3;
      }
      /* Cards area above the cabinet */
      #cards {
        position: absolute;
        left: 0; right: 0;
        bottom: calc(var(--cabinet-height));
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        align-items: end;
        justify-items: center;
        padding: 10px 12px;
        gap: 10px;
        height: var(--cards-height); /* bottom portion on mobile */
        pointer-events: none; /* cards display only for now */
      }
      .card {
        --card-bg: rgba(255,255,255,0.95);
        --card-ink: #111827; /* default dark ink */
        --card-accent: #ef4444; /* red for hearts/diamonds */
        width: min(22vw, 180px);
        aspect-ratio: 2.5 / 3.5; /* classic playing card ratio */
        border-radius: 10px;
        background: var(--card-bg);
        color: var(--card-ink);
        box-shadow: 0 8px 16px rgba(0,0,0,0.35);
        position: relative;
        padding: 8px;
        transition: transform 300ms ease, opacity 250ms ease; /* for use/discard animation */
        will-change: transform, opacity;
      }
      .card .corner {
        position: absolute;
        font-weight: 800;
        line-height: 1.05;
        text-align: center;
        color: var(--card-ink);
      }
      .card .corner.tl { top: 6px; left: 6px; }
      .card .corner.br { bottom: 6px; right: 6px; transform: rotate(180deg); }
      .card .center {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        font-size: 2.2rem;
        color: var(--card-ink);
      }
      .card .tag { position:absolute; left:50%; bottom:-18px; transform:translateX(-50%); background:rgba(2,6,23,0.8); color:var(--text); border:1px solid rgba(148,163,184,0.35); border-radius:999px; padding:2px 8px; font-size:0.7rem; font-weight:700; letter-spacing:0.3px; opacity:0; transition:opacity 200ms ease; pointer-events:none; white-space:nowrap; }
      /* Mobile priority sizing */
      @media (max-width: 767px) {
        #cards { height: var(--cards-height); }
        .card { width: min(26vw, 160px); }
      }
      /* Desktop tuning */
      @media (min-width: 768px) {
        :root { --cards-height: 24vh; }
        #cards {
          height: 24vh;
          display: flex;               /* side-by-side */
          justify-content: center;     /* centered horizontally */
          align-items: flex-end;       /* sit on the baseline */
          gap: 8px;                    /* small gap between cards */
          padding-left: 0;
          padding-right: 0;
          /* Move cards down by half of their height (≈98px for 140px width at 2.5:3.5 ratio) */
          bottom: calc(var(--cabinet-height) - 98px);
        }
        /* Sit the character area directly above the cards on desktop */
        #characterArea {
          bottom: calc(var(--cabinet-height) + (var(--cards-height) - 98px));
        }
        .card { width: 140px; }
      }
      /* Overlay + Modal for menus/lobbies */
      .overlay {
        position: fixed;
        inset: 0;
        display: grid;
        place-items: center;
        background: rgba(2, 6, 23, 0.84);
  z-index: 9999;
        padding: 16px;
        padding-bottom: calc(16px + var(--safe));
      }
      .modal {
        width: min(92vw, 420px);
        max-width: 92vw;
        max-height: 80vh;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        align-items: stretch;
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(148,163,184,0.25);
        padding: 18px 16px;
        border-radius: 14px;
        box-shadow: 0 12px 32px rgba(0,0,0,0.45);
      }
      .modal h2, .modal h3 { margin: 0 0 4px 0; text-align: center; }
      .form-row { display: flex; gap: 8px; align-items: center; width: 100%; }
      .input {
        flex: 1;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(148,163,184,0.35);
        background: rgba(2,6,23,0.6);
        color: #e5e7eb;
      }
      .btn { padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(148,163,184,0.35); font-weight: 800; }
      .btn-primary { background: #16a34a; color: #fff; }
      .btn-danger { background: #ef4444; color: #fff; }
      .btn-ghost { background: transparent; color: #e5e7eb; }
      .btn-wide { width: 100%; }
      /* Bottom cabinet */
      .cabinet {
        position: relative;
        padding-bottom: calc(var(--safe) + 8px);
        padding-left: 16px;
        padding-right: 16px;
        backdrop-filter: blur(6px);
        background: rgba(2, 6, 23, 0.66);
        border-top: 1px solid rgba(148, 163, 184, 0.25);
        display: grid;
        grid-template-columns: 1fr auto auto auto 1fr;
        align-items: center;
      }
      /* Left & right info */
      .metric {
        display: flex;
        flex-direction: column; /* stack label above value */
        align-items: center;
        justify-content: center; /* center contents within each column */
        gap: 4px;
        font-weight: 600;
        white-space: nowrap;
        justify-self: center; /* center the block within the grid cell */
        text-align: center;
      }
      .metric .label {
        color: var(--muted);
        font-weight: 500;
      }
      /* Center buy button */
      .buy {
        width: min(14.85vw, 121.5px); /* 25% smaller */
        height: min(14.85vw, 121.5px); /* 25% smaller */
        max-height: calc(var(--cabinet-height) - 12px);
        max-width: calc(var(--cabinet-height) - 12px);
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        display: grid;
        place-items: center;
        background: var(--accent);
        color: white;
        font-weight: 800;
        font-size: 1em; /* set button text to normal size */
        letter-spacing: 0.5px;
        text-align: center;
        box-shadow: 0 8px 24px rgba(239, 68, 68, 0.35);
        border: 2px solid rgba(255,255,255,0.25);
        cursor: pointer;
        user-select: none;
      }
      .buy[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
        filter: saturate(0.85) brightness(0.9);
        box-shadow: 0 4px 10px rgba(239, 68, 68, 0.18);
        pointer-events: none;
      }
      .buy small { display:block; font-weight:700; opacity:0.9; }
      .buy:active { transform: translateY(1px); }
      /* Responsive tweaks */
      @media (min-width: 768px) {
        :root { --cabinet-height: 12vh; }
        .buy { width: 94.5px; height: 94.5px; } /* 25% smaller on desktop */
      }

      /* Mobile font scaling: keep desktop perfect, scale down for small screens */
      @media (max-width: 767px) {
        body { font-size: 1.25rem; } /* slightly smaller for mobile to fit comfortably */
        .buy {
          font-size: 0.68em; /* another ~15% reduction from 0.8em */
          width: min(14.515875vw, 118.76625px); /* increase mobile circle by 15% */
          height: min(14.515875vw, 118.76625px);
        }
        .buy small { font-size: 0.68em; } /* reduce amount text similarly */
        .metric { font-size: 0.95em; }
        /* Ensure progress label dark green is visible on mobile */
        .progress .label {
          color: #064e3b;
          mix-blend-mode: normal;
        }
      }
      #monsterArea img.shake { animation: monster-shake 300ms ease; }
      /* Green tint for heal */
      #monsterArea img.healTint {
        filter: drop-shadow(0 10px 24px rgba(0,0,0,0.5)) sepia(0.2) saturate(1.3) hue-rotate(60deg) brightness(1.05);
        animation: monster-heal 500ms ease;
      }
      /* Red tint for damage */
      #monsterArea img.damageTint {
        filter: drop-shadow(0 10px 24px rgba(0,0,0,0.5)) sepia(0.4) saturate(1.6) hue-rotate(-20deg) brightness(0.95);
        animation: monster-damage 380ms ease;
      }
@keyframes monster-shake { 0%{transform:translateX(0)}20%{transform:translateX(-6px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}100%{transform:translateX(0)} }
@keyframes monster-heal { 0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)} }
@keyframes monster-damage { 0%{transform:scale(1)}50%{transform:scale(0.98)}100%{transform:scale(1)} }
    </style>
  </head>
  <body>
    <!-- Main Menu -->
    <section id="mainMenu" aria-label="Main Menu" class="overlay">
      <div class="modal">
        <h2>Card Combat</h2>
        <div class="form-row">
          <input id="nameInput" class="input" type="text" maxlength="24" placeholder="Your name" aria-label="Your name" />
        </div>
        <div class="form-row">
          <input id="joinCodeInput" class="input" type="text" inputmode="latin" maxlength="8" placeholder="Enter lobby code" aria-label="Lobby code" />
          <button id="joinBtn" class="btn btn-primary">Join</button>
        </div>
        <button id="createLobbyBtn" class="btn btn-danger btn-wide">Create Lobby</button>
      </div>
    </section>
    <script>
    // Utility to show only one overlay at a time
    function showOverlay(overlayId) {
      const overlays = document.querySelectorAll('.overlay');
      overlays.forEach(ov => {
          if (ov.id === overlayId) {
            console.log('[showOverlay] Showing overlay:', ov.id);
            ov.style.display = 'grid';
            ov.style.pointerEvents = 'auto';
          } else {
            ov.style.display = 'none';
            ov.style.pointerEvents = 'none';
          }
      });
      // Extra guard: hide any modal, backdrop, notification, or debug not inside the active overlay
      const activeOverlay = document.getElementById(overlayId);
      ['modal','backdrop','notification','debug'].forEach(cls => {
        document.querySelectorAll('.'+cls).forEach(el => {
          if (!activeOverlay || !activeOverlay.contains(el)) {
            el.style.display = 'none';
            el.style.pointerEvents = 'none';
          } else {
            el.style.display = '';
            el.style.pointerEvents = '';
          }
        });
      });
    }
    // Example: showOverlay('mainMenu'); // Only main menu visible
    // Call showOverlay('lobbyScreen') etc. as needed in your game flow
    // Optionally, show main menu on load
    window.addEventListener('DOMContentLoaded', () => {
      showOverlay('mainMenu');
    });
    </script>

    <!-- Lobby Screen -->
    <section id="lobbyScreen" aria-label="Lobby" class="overlay" style="display:none;">
      <div class="modal">
        <h3>Lobby</h3>
        <div><strong>Code:</strong> <span id="lobbyCodeText"></span></div>
        <div>
          <strong>Players</strong>
          <ul id="playerList" style="list-style:none; padding:0; margin:8px 0; display:flex; flex-direction:column; gap:6px;"></ul>
        </div>
  <button id="startGameBtn" class="btn btn-primary btn-wide" style="display:none;">Start Game</button>
        <button id="leaveLobbyBtn" class="btn btn-ghost btn-wide">Leave</button>
      </div>
    </section>
    <header class="progress-wrap" aria-label="Progress">
      <div class="progress-outer">
        <div id="levelBadge" aria-label="Monster level">1</div>
        <div class="progress" id="progressBar">
        <div class="fill" id="progressFill"></div>
  <div class="label" id="progressLabel">18000 / 20000</div>
        <!-- HP label removed -->
        </div>
      </div>
      <div id="jackpot" aria-live="polite">£5000</div>
    </header>
  <main id="game" aria-label="Game area" style="visibility:hidden;">
      <!-- Monster zone (between progress bar and character area) -->
  <button id="helpBtn" class="helpBtn" aria-label="How to Play" title="How to Play">?</button>
  <div id="debugDropdownWrap" style="position:absolute; right:12px; z-index:12; display:inline-block; left:unset;">
    <button id="debugBtn" class="cornerBtn" aria-label="Debug" title="Debug" style="display:none;">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
        <path d="M8 3v4M16 3v4" />
        <path d="M4 11h16" />
        <path d="M4 19h16" />
        <path d="M7 11v8m10-8v8" />
      </svg>
    </button>
    <div id="debugDropdown" style="display:none; position:absolute; right:100%; top:0; background:#222; border-radius:8px; box-shadow:0 4px 16px #0008; min-width:180px; z-index:99999; padding:8px 0; margin-right:10px;">
      <button class="debugAction" id="debugDrawJokers" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Draw 3 Jokers</button>
      <button class="debugAction" id="debugDrawFaces" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Draw 3 Face Cards</button>
      <button class="debugAction" id="debugRefreshBalance" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Refresh Balance (£100)</button>
      <button class="debugAction" id="debugShowNotification" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Show Test Notification</button>
      <button class="debugAction" id="debugSetHealth" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer; display:none;">Set Monster Health to 100</button>
    </div>
  </div>
  <section id="monsterArea" aria-label="Monster area" style="position: relative;">
  <!-- ...existing code... -->
    <!-- ...existing code... -->
  </section>
  <!-- Help/Rules Modal moved outside game area for stacking -->
  <section id="helpModal" class="overlay" style="display:none; position:fixed; z-index:2147483647;" aria-label="How to Play">
    <div class="modal" style="max-width: 480px;">
      <h2 style="margin-bottom:8px;">How to Play</h2>
      <div style="font-size:1.1rem; margin-bottom:10px;">Defeat monsters by playing cards. Each card suit has a different effect. Your stake increases your rewards and damage.</div>
      <ul style="margin-bottom:10px;">
        <li><b>Spades/Clubs</b>: Deal damage to the monster. Face cards do more.</li>
        <li><b>Diamonds</b>: Add to your prize. Higher stake = bigger prize.</li>
        <li><b>Hearts</b>: Heal yourself (and others with face cards).</li>
        <li><b>Joker</b>: Monster attacks random players. Red particles show who is hit.</li>
      </ul>
      <div style="margin-bottom:10px;">
        <b>Card Payouts (per £ stake):</b>
        <ul style="font-size:0.98rem;">
          <li>Number cards: Value/10 × stake (e.g. 7 = 0.7×stake)</li>
          <li>Jack: see below</li>
          <li>Queen: see below</li>
          <li>King: see below</li>
          <li>Ace: 5×stake (Diamonds/Hearts)</li>
        </ul>
      </div>
      <div style="margin-bottom:10px;">
        <b>Face Card Effects:</b>
        <ul style="font-size:0.98rem;">
          <li><b>Spade/Club J/Q/K</b>: Deal 11/12/13 damage × stake</li>
          <li><b>Diamond J/Q/K</b>: +1/1.5/3 × stake to prize</li>
          <li><b>Heart J</b>: Heal self 5, 2 others for 2</li>
          <li><b>Heart Q</b>: Heal self 10, 4 others for 4</li>
          <li><b>Heart K</b>: Heal self 15, 6 others for 6</li>
        </ul>
      </div>
      <div style="margin-bottom:10px;">
        <b>Tips:</b>
        <ul style="font-size:0.98rem;">
          <li>Drag your avatar to move horizontally.</li>
          <li>Only the lobby owner can start the game.</li>
          <li>Jackpot is a work in progress!</li>
        </ul>
      </div>
      <button id="closeHelpBtn" class="btn btn-ghost" style="margin-top:8px;">Close</button>
    </div>
  </section>
    <script>
      // Help/Rules modal logic
      const helpBtn = document.getElementById('helpBtn');
      const helpModal = document.getElementById('helpModal');
      const closeHelpBtn = document.getElementById('closeHelpBtn');
      if (helpBtn && helpModal) {
        helpBtn.onclick = () => { helpModal.style.display = 'grid'; };
      }
      if (closeHelpBtn && helpModal) {
        closeHelpBtn.onclick = () => { helpModal.style.display = 'none'; };
      }
      // Dismiss modal on overlay click
      if (helpModal) {
        helpModal.addEventListener('click', (e) => { if (e.target === helpModal) helpModal.style.display = 'none'; });
      }
      // Show How to Play menu on top by default
      // No automatic showing of How to Play menu
    </script>
        <div id="monsterSpriteWrap" style="position: relative; width: 100%; height: 50%;">
          <img id="monsterSprite" src="assets/ice_monster.png" alt="Ice Monster" style="position: absolute; top: 0; left: 50%; transform: translateX(-50%) scaleY(0.85); transform-origin: top center; max-width: 100%; height: 100%; object-fit: contain; z-index: 10;" />
        </div>
        </div>
  <div id="assistNotifications" style="position: absolute; left: 0; top: 120px; min-width: 120px; max-width: 220px; z-index: 10001; display: flex; flex-direction: column; gap: 10px; pointer-events: none; align-items: flex-start; margin-left: 0 !important;"></div>
  <!-- Defeat Banner -->
        <div id="defeatBanner" style="display:none; position:absolute; inset:0; display:none; align-items:center; justify-content:center;">
          <div style="background:rgba(2,6,23,0.85); color:#fde68a; border:1px solid rgba(148,163,184,0.35); border-radius:12px; padding:10px 16px; font-weight:800; letter-spacing:0.5px;">
            Monster Defeated
          </div>
        </div>
        <button id="statsBtn" class="cornerBtn" aria-label="Stats" title="Stats">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M3 3v18h18" />
            <rect x="7" y="13" width="3" height="5" />
            <rect x="12" y="9" width="3" height="9" />
            <rect x="17" y="5" width="3" height="13" />
          </svg>
        </button>
  <div id="debugDropdownWrap">
          <button id="debugBtn" class="cornerBtn" aria-label="Debug" title="Debug" style="display:none;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <path d="M8 3v4M16 3v4" />
              <path d="M4 11h16" />
              <path d="M4 19h16" />
              <path d="M7 11v8m10-8v8" />
            </svg>
          </button>
          <div id="debugDropdown" style="display:none; position:absolute; left:0; top:110%; background:#222; border-radius:8px; box-shadow:0 4px 16px #0008; min-width:180px; z-index:99999; padding:8px 0;">
            <button class="debugAction" id="debugDrawJokers" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Draw 3 Jokers</button>
            <button class="debugAction" id="debugDrawFaces" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Draw 3 Face Cards</button>
            <button class="debugAction" id="debugRefreshBalance" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Refresh Balance (£100)</button>
            <button class="debugAction" id="debugShowNotification" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer;">Show Test Notification</button>
            <button class="debugAction" id="debugSetHealth" style="width:100%; background:none; color:#fff; border:none; text-align:left; padding:8px 18px; font-size:1rem; cursor:pointer; display:none;">Set Monster Health to 100</button>
          </div>
        </div>
      </section>
      <!-- Character band -->
      <section id="characterArea" aria-label="Character area">
        <div id="player" class="playerUnit" style="left: 50%">
          <div class="hpBadge" id="playerHp" aria-live="polite">50 / 50</div>
          <div id="playerRect"></div>
          <div class="playerName" id="playerName">Player 1</div>
        </div>
      </section>
      <!-- Mobile-priority card draw area (bottom 30% of screen) -->
      <section id="cards" aria-label="Player cards"></section>
      <div id="effects" aria-hidden="true"></div>
    </main>
    <!-- Jackpot Modal -->
    <section id="jackpotModal" class="overlay" style="display:none;" aria-label="Jackpot Awarded">
      <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <h3 style="margin:0;">Jackpot Awarded!</h3>
          <button id="closeJackpot" class="btn btn-ghost">Close</button>
        </div>
        <div style="text-align:center; margin:12px 0 4px;">
          <div style="font-size:1.8rem; font-weight:900; color:#22c55e;" id="jackpotAwardAmount">£0</div>
          <div style="opacity:0.8; margin-top:6px;">Congratulations!</div>
        </div>
            <div style="opacity:0.85; font-size:0.9rem;">
              This will be functional once I know what the heck I plan to do with the jackpot
            </div>
        <div id="killSummary" style="margin-top:10px; display:flex; flex-direction:column; gap:6px;">
          <div style="opacity:0.8;">Summary</div>
          <div id="killAllocations"></div>
          <ol id="killLeaderboard" style="margin:8px 0; padding-left:18px;"></ol>
        </div>
      </div>
    </section>
    <!-- Stats Modal -->
    <section id="statsModal" class="overlay" style="display:none;" aria-label="Stats Modal">
      <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <h3 style="margin:0;">Battle Stats</h3>
          <button id="closeStats" class="btn btn-ghost">Close</button>
        </div>
        <div id="statsContent" style="display:flex; flex-wrap:wrap; gap:8px; margin:8px 0 4px;">
          <div class="capsule"><span class="cap-label">Hearts</span><span id="statHearts" class="cap-value">0</span></div>
          <div class="capsule"><span class="cap-label">Clubs</span><span id="statClubs" class="cap-value">0</span></div>
          <div class="capsule"><span class="cap-label">Spades</span><span id="statSpades" class="cap-value">0</span></div>
          <div class="capsule"><span class="cap-label">Diamonds</span><span id="statDiamonds" class="cap-value">0</span></div>
          <div class="capsule"><span class="cap-label">Prizes</span><span id="statPrizes" class="cap-value">£0</span></div>
          <div class="capsule"><span class="cap-label">Damage</span><span id="statDamage" class="cap-value">0</span></div>
        </div>
        <style>
          .capsule{ display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:rgba(2,6,23,0.8); border:1px solid rgba(148,163,184,0.25); }
          .cap-label{ opacity:0.8; font-size:0.85rem; }
          .cap-value{ font-weight:800; font-variant-numeric: tabular-nums; }
          .lb-capsules{ display:flex; flex-wrap:wrap; gap:8px; }
          .lb-item{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background:rgba(2,6,23,0.8); border:1px solid rgba(148,163,184,0.25); min-width: 180px; }
          .lb-pos{ width:22px; height:22px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-weight:800; font-size:0.8rem; color:#0b1020; }
          .lb-medal-1{ background: linear-gradient(135deg,#facc15,#f59e0b); }
          .lb-medal-2{ background: linear-gradient(135deg,#cbd5e1,#94a3b8); }
          .lb-medal-3{ background: linear-gradient(135deg,#f59e0b,#b45309); }
          .lb-medal-n{ background:#94a3b8; color:#0b1020; }
          .lb-name{ font-weight:600; opacity:0.95; }
          .lb-dmg{ margin-left:auto; font-weight:800; font-variant-numeric: tabular-nums; }
        </style>
        <hr style="opacity:0.3;"/>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
            <strong>Leaderboard (This Monster)</strong>
            <div id="myRank" style="opacity:0.9;"></div>
          </div>
          <div id="leaderCaps" class="lb-capsules"></div>
        </div>
      </div>
    </section>
    <!-- Shared Prize Chest Overlay -->
  <div id="chestOverlay" style="position:fixed; right:24px; bottom:8vh; z-index:999; display:flex; flex-direction:column; align-items:center; pointer-events:auto;">
      <button id="chestBtn" style="background:none; border:none; padding:0; cursor:pointer; outline:none; position:relative;">
        <img src="assets/treasure-chest.png" alt="Shared Prize Chest" id="chestImg" style="width:64px; height:64px; transition:box-shadow 0.3s, filter 0.3s; box-shadow:0 4px 16px rgba(250,204,21,0.18);" />
        <span id="chestPulse" style="position:absolute; left:0; top:0; width:64px; height:64px; border-radius:50%; pointer-events:none; display:none;"></span>
      </button>
      <span id="chestAmount" style="margin-top:4px; font-weight:800; color:#facc15; font-size:1.1rem; text-shadow:0 1px 2px rgba(0,0,0,0.45);">£0</span>
    </div>
    <!-- Chest Log Modal -->
    <section id="chestLogModal" class="overlay" style="display:none; z-index:1001;" aria-label="Shared Prize Log">
      <div class="modal">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <h3 style="margin:0;">Shared Prize Log</h3>
          <button id="closeChestLog" class="btn btn-ghost">Close</button>
        </div>
        <div id="chestLogContent" style="margin-top:10px; font-size:1rem;"></div>
      </div>
    </section>
    <footer class="cabinet" aria-label="Controls cabinet">
    <script>
    // --- Chest Overlay Logic ---
    const chestBtn = document.getElementById('chestBtn');
    const chestImg = document.getElementById('chestImg');
    const chestPulse = document.getElementById('chestPulse');
    const chestAmount = document.getElementById('chestAmount');
    const chestOverlay = document.getElementById('chestOverlay');
    const chestLogModal = document.getElementById('chestLogModal');
    const closeChestLog = document.getElementById('closeChestLog');
    const chestLogContent = document.getElementById('chestLogContent');

    // Track shared prizes since last chest opening
    let sharedPrizeLog = [];
    let sharedPrizeTotal = 0;

    // Call this when a shared prize is received from another player
    function addSharedPrize(amount, fromPlayer) {
      // If this player already exists in the log, sum their amount
      const existing = sharedPrizeLog.find(e => e.fromPlayer === fromPlayer);
      if (existing) {
        existing.amount += amount;
      } else {
        sharedPrizeLog.push({ amount, fromPlayer });
      }
      sharedPrizeTotal += amount;
      chestAmount.textContent = '£' + sharedPrizeTotal.toFixed(2);
      pulseChest();
    }

    // Pulse animation for chest
    function pulseChest() {
      chestImg.style.filter = 'drop-shadow(0 0 16px #facc15) brightness(1.15)';
      chestImg.style.boxShadow = '0 0 32px 8px #facc15';
      chestPulse.style.display = 'block';
      chestPulse.animate([
        { boxShadow: '0 0 0 0 #facc15', opacity: 0.7 },
        { boxShadow: '0 0 32px 16px #facc15', opacity: 0.2 },
        { boxShadow: '0 0 0 0 #facc15', opacity: 0 }
      ], { duration: 700, easing: 'ease-out' });
      setTimeout(() => {
        chestImg.style.filter = '';
        chestImg.style.boxShadow = '0 4px 16px rgba(250,204,21,0.18)';
        chestPulse.style.display = 'none';
      }, 700);
    }

    // Chest button opens log modal
    if (chestBtn && chestLogModal) {
      chestBtn.onclick = () => {
        // Build log content
        if (sharedPrizeLog.length === 0) {
          chestLogContent.innerHTML = '<div style="opacity:0.7;">No shared prizes since last opening.</div>';
        } else {
          let html = '<ul style="padding-left:0; list-style:none;">';
          for (const entry of sharedPrizeLog) {
            html += `<li style="margin-bottom:6px;">+£${entry.amount.toFixed(2)} <span style="opacity:0.8;">from</span> <b>${entry.fromPlayer}</b></li>`;
          }
          html += '</ul>';
          html += `<div style="margin-top:10px; font-weight:800; color:#facc15;">Total: £${sharedPrizeTotal.toFixed(2)}</div>`;
        }
        chestLogModal.style.display = 'grid';
      };
    }
    if (closeChestLog && chestLogModal) {
      closeChestLog.onclick = () => {
        chestLogModal.style.display = 'none';
        // Reset log after viewing
        sharedPrizeLog = [];
        sharedPrizeTotal = 0;
        chestAmount.textContent = '£0';
      };
    }
    // Only update the chest when players on the network share a heal or a prize with this client
    </script>
      <div class="metric" id="balance">
        <span class="label">Balance</span>
        <span class="value" aria-live="polite">£100</span>
      </div>
      <!-- stake minus button -->
      <button class="buy-step" id="stakeMinus" aria-label="Decrease Stake">−</button>
      <button class="buy" id="buyBtn" aria-label="Buy In">
        <div>
          <div>Buy In</div>
          <small>£1</small>
        </div>
      </button>
      <!-- stake plus button -->
      <button class="buy-step" id="stakePlus" aria-label="Increase Stake">+</button>
      <div class="metric" id="prize">
        <span class="label">Prize</span>
        <span class="value" aria-live="polite">£0</span>
      </div>
      <!-- removed stake input -->
    </footer>
    <script>
      // --- Simple client-side lobby routing (no backend) ---
      // Uses URL hash (? or #) code and localStorage to simulate shared lobby on same device.
      const mainMenuEl = document.getElementById('mainMenu');
      const lobbyEl = document.getElementById('lobbyScreen');
      const lobbyCodeText = document.getElementById('lobbyCodeText');
      const playerListEl = document.getElementById('playerList');
      const startGameBtn = document.getElementById('startGameBtn');
      const leaveLobbyBtn = document.getElementById('leaveLobbyBtn');
      const createLobbyBtn = document.getElementById('createLobbyBtn');
      const joinBtn = document.getElementById('joinBtn');
      const joinCodeInput = document.getElementById('joinCodeInput');
  const nameInput = document.getElementById('nameInput');
      // WebSocket backend wiring
      let ws = null;
      let wsConnected = false;
  let latestRoster = [];
  let selfId = null;
  const lobbyPlayers = new Map(); // id -> { name, hp, el }
    // Track the monster key used for server leaderboards
    let currentMonsterKey = null;
    let pendingMonsterKey = null;
      function getDefaultWsUrl(){
        // Always use Render in production; keep localhost for local development
        const host = location.hostname;
        if (host === 'localhost' || host === '127.0.0.1') return 'ws://localhost:8080';
        return 'wss://card-combat-server.onrender.com';
      }
      function connectWS(url){
        if (!url) return;
        try {
          ws = new WebSocket(url);
        } catch { return; }
        ws.addEventListener('open', ()=>{ wsConnected = true; console.log('WS connected');
          // Send pending monster key if we picked a monster before WS was ready
          try {
            if (pendingMonsterKey) {
              ws.send(JSON.stringify({ type: 'setMonster', key: pendingMonsterKey }));
              currentMonsterKey = pendingMonsterKey; pendingMonsterKey = null;
            }
          } catch {}
        });
        ws.addEventListener('close', ()=>{ wsConnected = false; console.log('WS closed'); });
        ws.addEventListener('error', ()=>{ wsConnected = false; console.log('WS error'); });
        ws.addEventListener('message', (ev)=>{
          console.log('[WS] Message received:', ev.data);
          let msg = {}; try { msg = JSON.parse(ev.data); } catch { return; }
          if (msg.type === 'created') {
            const code = msg.code;
            if (msg.you) { selfId = msg.you.id; setSelfIdentity(msg.you.name || selfName); }
            location.hash = '#' + code;
            // Populate player list with just ourselves for now
            renderLobby(code, [{ id: selfId, name: selfName }]);
            // Show Start Game button if we're the owner (creator)
            const startGameBtn = document.getElementById('startGameBtn');
            if (startGameBtn) startGameBtn.style.display = 'block';
            showOverlay('lobbyScreen');
          } else if (msg.type === 'slashAttackOverlay') {
            if (typeof playSlashAttackOverlay === 'function') playSlashAttackOverlay();
          } else if (msg.type === 'sharedPrize') {
            // Only process if the prize is for us (the server only sends to the correct recipient)
            const amount = Math.max(0, Number(msg.amount) || 0);
            const fromName = msg.fromName || 'Another player';
            if (amount > 0) {
              addSharedPrize(amount, fromName);
              showAssistNotification(`${fromName} shared £${amount.toFixed(2)} with you!`);
            }
            const code = msg.code; if (!code) return;
            if (msg.you) { selfId = msg.you.id; setSelfIdentity(msg.you.name || selfName); }
            location.hash = '#' + code;
            renderLobby(code);
            showOverlay('lobbyScreen');
          } else if (msg.type === 'joined') {
            const code = msg.code; if (!code) return;
            if (msg.you) { selfId = msg.you.id; setSelfIdentity(msg.you.name || selfName); }
            location.hash = '#' + code;
            // Use latestRoster if available, otherwise just self
            const players = Array.isArray(msg.players) ? msg.players : [{ id: selfId, name: selfName }];
            renderLobby(code, players);
            showOverlay('lobbyScreen');
          } else if (msg.type === 'roster') {
            latestRoster = Array.isArray(msg.players) ? msg.players : [];
          console.log('[WS] Handling roster message. code:', code, 'players:', latestRoster);
          const code = msg.code || (location.hash||'').replace('#','');
          renderLobby(code, latestRoster);
          console.log('[WS] Calling showOverlay("lobbyScreen")');
          showOverlay('lobbyScreen');
          // Apply any provided normalized positions to avatars
          try {
              const area = document.getElementById('characterArea');
              if (area) {
                const rect = area.getBoundingClientRect();
                for (const p of latestRoster) {
                  const id = p.id || p.name; const entry = lobbyPlayers.get(id);
                  if (!entry || !entry.el) continue;
                  const xn = Number(p.x);
                  if (Number.isFinite(xn)) {
                    const rectEl = entry.el.querySelector('#playerRect') || entry.el.querySelector('.playerRect');
                    const rectW = rectEl ? rectEl.getBoundingClientRect().width : 20;
                    const xnClamped = Math.max(0, Math.min(1, xn));
                    const px = (rect.width - rectW) * xnClamped + rectW/2;
                    entry.el.style.left = px + 'px';
                  }
                }
              }
            } catch {}
            // Owner-only debug button toggle
            try {
              ownerId = msg.ownerId || null;
              if (debugBtn) debugBtn.style.display = 'block';
              // Show/hide owner-only debug action
              const debugSetHealth = document.getElementById('debugSetHealth');
              if (debugSetHealth) debugSetHealth.style.display = (selfId && ownerId && String(ownerId) === String(selfId)) ? 'block' : 'none';
              // Show Start Game button only for lobby owner
              const startGameBtn = document.getElementById('startGameBtn');
              if (startGameBtn) {
                if (selfId && ownerId && String(ownerId) === String(selfId)) {
                  startGameBtn.style.display = 'block';
                } else {
                  startGameBtn.style.display = 'none';
                }
              }
            } catch {}
          } else if (msg.type === 'jackpotState') {
            const value = Number(msg.jackpot) || 0;
            jackpot = Number(value.toFixed(2));
            updateJackpotDisplay();
          } else if (msg.type === 'monsterSet') {
            // Server acknowledged/changed current monster key
            if (msg && typeof msg.key === 'string') currentMonsterKey = msg.key;
            // Reset defeat UI in case we're moving to a new monster
            try { if (typeof resetDefeatUX === 'function') resetDefeatUX(); } catch {}
          } else if (msg.type === 'started') {
            showGame();
          } else if (msg.type === 'damageMonster') {
            const amt = Math.max(0, Number(msg.amount)||0);
            if (amt > 0) {
              progress = Math.max(0, progress - amt);
              const pct = goal > 0 ? (progress / goal) : 0;
              progressFill.style.width = `${pct * 100}%`;
              progressLabel.textContent = `${progress} / ${goal}`;
              monsterFeedback('damage');
              if (progress <= 0) { showDefeatSequence(); }
              // Show damage particles from the acting player's avatar (if not self-triggered already)
              try {
                const suit = msg.suit === 'club' ? 'club' : (msg.suit === 'spade' ? 'spade' : null);
                const by = msg.by;
                if (suit && by) spawnParticlesFromPlayerById(by, suit);
              } catch {}
            }
          } else if (msg.type === 'healPlayer') {
            // Only show heal animation/notification if this is us
            const { id, amount, byName } = msg; if (!id) return;
            if (id === (selfId || 'self')) {
              spawnHeartRingForPlayer(id);
              if (typeof byName === 'string' && byName.trim().length > 0 && byName !== selfName) {
                showAssistNotification(`${byName} healed you for ${amount}`);
              }
            }
          } else if (msg.type === 'jokerAttack') {
            const dmg = Math.max(1, Number(msg.damage)||1);
            const targets = Array.isArray(msg.targets) ? msg.targets : [];
            showMonsterAttackOverlay();
            // For each hit player, spawn bright red particles from monster to them
            try {
              const sprite = document.getElementById('monsterSprite');
              const effects = document.getElementById('effects');
              if (sprite && effects) {
                const rectM = sprite.getBoundingClientRect();
                for (const id of targets) {
                  const unit = id === (selfId || 'self') ? document.getElementById('player') : document.querySelector(`[data-player-id="${id}"]`);
                  if (!unit) continue;
                  const rectU = unit.getBoundingClientRect();
                  const startX = rectM.left + rectM.width / 2;
                  const startY = rectM.top + rectM.height * 0.3;
                  const endX = rectU.left + rectU.width / 2;
                  const endY = rectU.top + 10;
                  for (let i = 0; i < 12; i++) {
                    const p = document.createElement('div');
                    p.style.position = 'fixed';
                    p.style.left = `${startX}px`;
                    p.style.top = `${startY}px`;
                    p.style.width = '6px';
                    p.style.height = '6px';
                    p.style.borderRadius = '999px';
                    p.style.background = '#ff1a1a'; // bright red
                    p.style.boxShadow = '0 0 8px rgba(255,26,26,0.8)';
                    p.style.opacity = '0.95';
                    effects.appendChild(p);
                    const dx = endX - startX;
                    const dy = endY - startY;
                    const jitterX = (Math.random() - 0.5) * 20;
                    const jitterY = (Math.random() - 0.5) * 10;
                    const keyframes = [
                      { transform: 'translate(0,0)', opacity: 0.9 },
                      { transform: `translate(${dx * 0.6 + jitterX}px, ${dy * 0.6 + jitterY}px)`, opacity: 1 },
                      { transform: `translate(${dx}px, ${dy}px)`, opacity: 0 }
                    ];
                    const duration = 520 + Math.random() * 280;
                    const easing = 'cubic-bezier(0.22, 1, 0.36, 1)';
                    const anim = p.animate(keyframes, { duration, easing, fill: 'forwards' });
                    anim.finished.catch(()=>{}).finally(()=>{ p.remove(); });
                  }
                  // Show red notification if this is the local player
                  if (id === (selfId || 'self') && typeof currentMonster === 'object' && currentMonster && currentMonster.name) {
                    showAssistNotification(`${currentMonster.name} attacked you for ${dmg} damage!`, true);
                  }
                }
              }
            } catch {}
            // Damage will be synced by healthSync; just show effects
          } else if (msg.type === 'playerPos') {
            const id = msg.id; const xn = Number(msg.x);
            if (!id || !Number.isFinite(xn)) return;
            const entry = lobbyPlayers.get(id);
            if (!entry || !entry.el) return;
            const area = document.getElementById('characterArea'); if (!area) return;
            const rect = area.getBoundingClientRect();
            const rectEl = entry.el.querySelector('#playerRect') || entry.el.querySelector('.playerRect');
            const rectW = rectEl ? rectEl.getBoundingClientRect().width : 20;
            const xnClamped = Math.max(0, Math.min(1, xn));
            const px = (rect.width - rectW) * xnClamped + rectW/2;
            entry.el.style.left = px + 'px';
          } else if (msg.type === 'jackpotAward') {
            try {
              if (typeof msg.total === 'number' && jackpotAwardAmount) {
                jackpotAwardAmount.textContent = formatCurrency(msg.total);
              }
              // Allocations list
              const allocWrap = document.getElementById('killAllocations');
              if (allocWrap) {
                allocWrap.innerHTML = '';
                const allocs = Array.isArray(msg.allocations) ? msg.allocations : [];
                for (const a of allocs) {
                  const row = document.createElement('div');
                  row.style.display = 'flex';
                  row.style.justifyContent = 'space-between';
                  row.style.gap = '8px';
                  const nm = document.createElement('div');
                  nm.textContent = a.name || a.id || 'Player';
                  const am = document.createElement('div');
                  am.textContent = formatCurrency(Number(a.amount)||0);
                  am.style.fontWeight = '800';
                  row.appendChild(nm); row.appendChild(am);
                  allocWrap.appendChild(row);
                }
              }
              // Final leaderboard top 10
              const killTop = document.getElementById('killLeaderboard');
              if (killTop) {
                killTop.innerHTML = '';
                const list = Array.isArray(msg.top) ? msg.top : [];
                for (const it of list.slice(0, 10)) {
                  const li = document.createElement('li');
                  const nm = it.name || it.id || 'Player';
                  const dmg = Number(it.damage)||0;
                  li.textContent = `${nm} — ${dmg}`;
                  killTop.appendChild(li);
                }
              }
              // Ensure jackpot modal is visible
              if (jackpotModal) jackpotModal.style.display = 'grid';
            } catch {}
          } else if (msg.type === 'jackpotUpdate') {
            const next = Number(msg.jackpot) || 0;
            jackpot = Number(next.toFixed(2));
            updateJackpotDisplay();
          } else if (msg.type === 'heartHeal') {
            const healAmt = Math.max(0, Number(msg.amount)||0);
            const targets = Array.isArray(msg.targets) ? msg.targets : [];
            const byName = msg.byName || '';
            for (const id of targets) {
              if (id === (selfId || 'self')) {
                spawnHeartRingForPlayer(id);
                if (byName && byName !== selfName) {
                  showAssistNotification(`${byName} healed you for ${healAmt}`);
                }
              }
            }
          } else if (msg.type === 'setMonsterHealth') {
            const h = Number(msg.health);
            if (Number.isFinite(h)) {
              progress = Math.max(0, Math.min(goal, Math.floor(h)));
              const pct = goal > 0 ? (progress / goal) : 0;
              progressFill.style.width = `${pct * 100}%`;
              progressLabel.textContent = `${progress} / ${goal}`;
              if (progress <= 0) { showDefeatSequence(); }
            }
          } else if (msg.type === 'stats') {
            // Populate leaderboard capsules (always 10 entries)
            try {
              const wrap = document.getElementById('leaderCaps');
              if (wrap) {
                wrap.innerHTML = '';
                const list = Array.isArray(msg.top) ? msg.top : (Array.isArray(msg.entries) ? msg.entries : []);
                for (let i = 0; i < 10; i++) {
                  const it = list[i];
                  const pos = i + 1;
                  const item = document.createElement('div'); item.className = 'lb-item';
                  const posEl = document.createElement('div'); posEl.className = 'lb-pos ' + (pos===1?'lb-medal-1':pos===2?'lb-medal-2':pos===3?'lb-medal-3':'lb-medal-n'); posEl.textContent = String(pos);
                  const nameEl = document.createElement('div'); nameEl.className = 'lb-name'; nameEl.textContent = it ? (it.name || it.id || 'Player') : '—';
                  const dmgEl = document.createElement('div'); dmgEl.className = 'lb-dmg'; dmgEl.textContent = it ? String(Number(it.damage)||0) : '0';
                  item.appendChild(posEl); item.appendChild(nameEl); item.appendChild(dmgEl);
                  wrap.appendChild(item);
                }
              }
            } catch {}
          } else if (msg.type === 'leaderboardUpdate') {
            try {
              const list = Array.isArray(msg.top) ? msg.top : [];
              const wrap = document.getElementById('leaderCaps');
              if (wrap) {
                wrap.innerHTML = '';
                for (let i = 0; i < 10; i++) {
                  const it = list[i]; const pos = i+1;
                  const item = document.createElement('div'); item.className = 'lb-item';
                  const posEl = document.createElement('div'); posEl.className = 'lb-pos ' + (pos===1?'lb-medal-1':pos===2?'lb-medal-2':pos===3?'lb-medal-3':'lb-medal-n'); posEl.textContent = String(pos);
                  const nameEl = document.createElement('div'); nameEl.className = 'lb-name'; nameEl.textContent = it ? (it.name || it.id || 'Player') : '—';
                  const dmgEl = document.createElement('div'); dmgEl.className = 'lb-dmg'; dmgEl.textContent = it ? String(Number(it.damage)||0) : '0';
                  item.appendChild(posEl); item.appendChild(nameEl); item.appendChild(dmgEl);
                  wrap.appendChild(item);
                }
              }
              const upd = msg.updated;
              if (upd && myRankEl) {
                myRankEl.textContent = `You: #${upd.rank || 0} • ${upd.total || 0} dmg`;
              }
            } catch {}
          }
        });
      }

      // Helpers
      function genCode(){
        const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let s = '';
        for (let i = 0; i < 6; i++) s += alphabet[Math.floor(Math.random()*alphabet.length)];
        return s;
      }
      function getLobbyStore(){
        try { return JSON.parse(localStorage.getItem('cc_lobbies')||'{}'); } catch { return {}; }
      }
      function setLobbyStore(data){ localStorage.setItem('cc_lobbies', JSON.stringify(data)); }
      function addPlayerToLobby(code, name){
        const store = getLobbyStore();
        if (!store[code]) store[code] = { players: [] };
        if (!store[code].players.includes(name)) store[code].players.push(name);
        setLobbyStore(store);
      }
      function removePlayerFromLobby(code, name){
        const store = getLobbyStore();
        if (store[code]) { store[code].players = store[code].players.filter(p=>p!==name); setLobbyStore(store); }
      }
      function renderLobby(code, playersFromServer){
        lobbyCodeText.textContent = code;
        playerListEl.innerHTML = '';
        const players = Array.isArray(playersFromServer)
          ? playersFromServer.map(p=>({ id: p.id || p.name, name: p.name || String(p) }))
          : (getLobbyStore()[code]?.players || []);
        for (const p of players){
          const li = document.createElement('li');
          li.textContent = p.name || String(p);
          playerListEl.appendChild(li);
        }
        // Also render player avatars in the character band
        renderLobbyAvatars(players);
        // Patch: Always show Start Game button for self if ownerId is not yet set but we just created the lobby
        const startGameBtn = document.getElementById('startGameBtn');
        if (startGameBtn) {
          // If ownerId is not set, but we are the only player, assume we are the owner
          if ((typeof ownerId === 'undefined' || ownerId === null) && players.length === 1 && players[0].id === selfId) {
            startGameBtn.style.display = 'block';
          }
        }
      }

      function setSelfIdentity(name){
        try { localStorage.setItem('cc_self_name', name); } catch {}
      }

      function renderLobbyAvatars(players){
        try {
          if (!Array.isArray(players)) players = [];
          const area = document.getElementById('characterArea');
          if (!area) return;
          // Remove any existing cloned units (keep #player as the local player)
          for (const el of Array.from(area.querySelectorAll('.playerUnit'))){
            if (el.id !== 'player') el.remove();
          }
          lobbyPlayers.clear();
          // Update local player's displayed name
          const localNameEl = document.getElementById('playerName');
          if (localNameEl) localNameEl.textContent = selfName;
          // Compute available width for random placement
          const areaRect = area.getBoundingClientRect();
          function rectWidthFor(el){ const r = el?.querySelector('#playerRect') || el?.querySelector('.playerRect'); return r ? r.getBoundingClientRect().width : 20; }
          function clampPos(x, rectW){ const minX = rectW/2 + 8; const maxX = Math.max(minX + 1, areaRect.width - rectW/2 - 8); return Math.max(minX, Math.min(maxX, x)); }
          function randomX(rectW){ const minX = rectW/2 + 8; const maxX = Math.max(minX + 1, areaRect.width - rectW/2 - 8); return Math.floor(Math.random() * (maxX - minX) + minX); }
          // Create a unit for each remote player
          for (const p of players){
            const pid = p.id || p.name;
            const name = p.name || String(p);
            if (name === selfName || pid === selfId) continue;
            const unit = document.createElement('div');
            unit.className = 'playerUnit';
            // Position using normalized x if provided, else random
            const xn = Number(p.x);
            if (Number.isFinite(xn)) {
              // Need a rect width; temporarily append to measure
              document.body.appendChild(unit);
              const rw = rectWidthFor(unit);
              const xnClamped = Math.max(0, Math.min(1, xn));
              const px = (areaRect.width - rw) * xnClamped + rw/2;
              unit.style.left = px + 'px';
              area.appendChild(unit);
            } else {
              // Random position using measured width
              document.body.appendChild(unit);
              const rw = rectWidthFor(unit);
              unit.style.left = randomX(rw) + 'px';
              area.appendChild(unit);
            }
            // HP badge
            const hp = document.createElement('div');
            hp.className = 'hpBadge';
            hp.textContent = '50 / 50';
            // Body
            const rect = document.createElement('div');
            rect.className = 'playerRect';
            // Name label
            const label = document.createElement('div');
            label.className = 'playerName';
            label.textContent = name;
            unit.appendChild(hp);
            unit.appendChild(rect);
            unit.appendChild(label);
            area.appendChild(unit);
            lobbyPlayers.set(pid, { name, hp: 50, el: unit });
          }
          // Register self
          lobbyPlayers.set(selfId || 'self', { name: selfName, hp: 50, el: document.getElementById('player') });
        } catch {}
      }

      function updateHpBadgeFor(id){
        const entry = lobbyPlayers.get(id);
        if (!entry || !entry.el) return;
        const badge = entry.el.querySelector('.hpBadge');
        if (badge) badge.textContent = `${Math.max(0, entry.hp)} / 50`;
      }
      function applyHealToPlayer(id, amount, fromName){
        // No-op: health is now server authoritative
      }

      // Show a notification to the left of the monster
      function showAssistNotification(text, isRed) {
  const wrap = document.getElementById('assistNotifications');
  if (!wrap) return;
  const note = document.createElement('div');
  note.textContent = text;
  if (isRed) {
    note.style.background = 'linear-gradient(90deg, rgba(239,68,68,0.95) 0%, rgba(239,68,68,0.0) 100%)';
    note.style.color = '#fff';
  } else {
    note.style.background = 'linear-gradient(90deg, rgba(34,197,94,0.95) 0%, rgba(34,197,94,0.0) 100%)';
    note.style.color = '#fff';
  }
  note.style.fontWeight = '700';
  note.style.fontSize = '0.6rem';
  note.style.borderRadius = '0 12px 12px 0';
  note.style.padding = '7px 22px 7px 16px';
  note.style.boxShadow = '0 2px 10px rgba(34,197,94,0.10)';
  note.style.opacity = '0';
  note.style.transform = 'translateY(10px)';
  note.style.transition = 'opacity 0.22s, transform 0.22s';
  note.style.marginLeft = '0';
  note.style.marginRight = '0';
  note.style.position = 'relative';
  note.style.left = '0';
  note.style.top = '0';
  note.style.right = 'auto';
  note.style.width = 'auto';
  note.style.maxWidth = '220px';
  note.style.minWidth = '120px';
  note.style.boxSizing = 'border-box';
  note.style.textShadow = '0 1px 2px rgba(0,0,0,0.12)';
  note.style.pointerEvents = 'none';
  // Remove alignSelf and relative position to avoid flex/gap issues
  note.style.alignSelf = '';
  // Do not change wrap display, keep as flex column for stacking
  wrap.style.gap = '10px';
  wrap.style.paddingLeft = '0';
  wrap.style.marginLeft = '0';
  wrap.appendChild(note);
  // Ensure parent has no gap or padding on left
  wrap.style.gap = '0';
  wrap.style.paddingLeft = '0';
  wrap.style.marginLeft = '0';
  // Animate in
// Wire up debug test notification after DOMContentLoaded
window.addEventListener('DOMContentLoaded', () => {
  const debugShowNotification = document.getElementById('debugShowNotification');
  if (debugShowNotification) {
    debugShowNotification.addEventListener('click', ()=>{
      const debugDropdown = document.getElementById('debugDropdown');
      if (debugDropdown) debugDropdown.style.display = 'none';
      showAssistNotification('Test notification: This should be flush left!');
    });
  }
});
      // Dynamically align debug button below stats button
      window.addEventListener('DOMContentLoaded', () => {
        const statsBtn = document.getElementById('statsBtn');
        const debugDropdownWrap = document.getElementById('debugDropdownWrap');
        if (statsBtn && debugDropdownWrap) {
          // Place debug button directly below stats button, with 10px gap and same left alignment
          debugDropdownWrap.style.top = (statsBtn.offsetTop + statsBtn.offsetHeight + 10) + 'px';
          debugDropdownWrap.style.left = statsBtn.offsetLeft + 'px';
          debugDropdownWrap.style.right = '';
        }
      });
        setTimeout(() => {
          note.style.opacity = '1';
          note.style.transform = 'translateY(0)';
        }, 10);
        // Animate out and remove after 2.2s
        setTimeout(() => {
          note.style.opacity = '0';
          note.style.transform = 'translateY(-10px)';
          setTimeout(() => note.remove(), 350);
        }, 2200);
      }
      function applyJokerDamageToTargets(dmg, targets){
        // No-op: health is now server authoritative
      }
      function showMonsterAttackOverlay(){
        const area = document.getElementById('monsterArea');
        if (!area) return;
        const tag = document.createElement('div');
        tag.textContent = 'Attack!';
        tag.style.position = 'absolute';
        tag.style.top = '8px';
        tag.style.left = '50%';
        tag.style.transform = 'translateX(-50%)';
        tag.style.background = 'rgba(2,6,23,0.8)';
        tag.style.color = '#fde68a';
        tag.style.border = '1px solid rgba(148,163,184,0.35)';
        tag.style.borderRadius = '999px';
        tag.style.padding = '4px 10px';
        tag.style.fontWeight = '800';
        tag.style.fontSize = '0.9rem';
        tag.style.pointerEvents = 'none';
        tag.style.opacity = '0';
        tag.style.zIndex = '4';
        area.appendChild(tag);
        try {
          const anim = tag.animate([
            { transform: 'translate(-50%, 0) scale(0.9)', opacity: 0 },
            { transform: 'translate(-50%, 0) scale(1)', opacity: 1 },
            { transform: 'translate(-50%, 0) scale(1.05)', opacity: 0 }
          ], { duration: 800, easing: 'ease-out', fill: 'forwards' });
          anim.finished.then(()=> tag.remove()).catch(()=> tag.remove());
        } catch {
          // Fallback
          tag.style.transition = 'opacity 200ms ease';
          requestAnimationFrame(()=>{ tag.style.opacity = '1'; });
          setTimeout(()=>{ tag.style.opacity = '0'; setTimeout(()=> tag.remove(), 220); }, 600);
        }
      }
      function applyJokerDamageToAll(dmg){
        for (const [id, entry] of lobbyPlayers){
          entry.hp = Math.max(0, (entry.hp || 0) - dmg);
          updateHpBadgeFor(id);
          if (entry.el && id === (selfId || 'self')) {
            const rect = entry.el.querySelector('#playerRect') || entry.el.querySelector('.playerRect');
            if (rect) {
              rect.classList.add('hit');
              setTimeout(()=>rect.classList.remove('hit'), 260);
            }
          }
        }
      }
      function showMenu(){ showOverlay('mainMenu'); document.getElementById('game').style.visibility='hidden'; }
      function showLobby(){ showOverlay('lobbyScreen'); document.getElementById('game').style.visibility='hidden'; }
      function showGame(){ mainMenuEl.style.display='none'; lobbyEl.style.display='none'; document.getElementById('game').style.visibility='visible'; }

      // Basic identity on this device
      let selfName = (()=>{
        const k='cc_self_name';
        let n = localStorage.getItem(k);
        if (!n) { n = 'Player-' + Math.floor(1000+Math.random()*9000); localStorage.setItem(k,n); }
        return n;
      })();
      // Pre-fill name input
      try { if (nameInput) nameInput.value = selfName; } catch {}
      function updateSelfNameFromInput(){
        const val = String(nameInput?.value || '').trim().slice(0,24) || selfName;
        selfName = val;
        setSelfIdentity(val);
      }

      // Navigation
      function navigateToLobby(code){
        if (!code) return;
        location.hash = '#'+code;
        addPlayerToLobby(code, selfName);
        renderLobby(code);
        showLobby();
      }
      function leaveLobby(){
        const code = (location.hash||'').replace('#','');
        if (code) removePlayerFromLobby(code, selfName);
        location.hash = '';
        showMenu();
      }

      // Wire buttons
      createLobbyBtn?.addEventListener('click', ()=>{
        updateSelfNameFromInput();
        console.log('[CreateLobbyBtn] Clicked. wsConnected:', wsConnected, 'ws:', ws);
        if (wsConnected && ws) {
          console.log('[CreateLobbyBtn] Sending create lobby to server');
          ws.send(JSON.stringify({ type: 'create', name: selfName }));
        } else {
          console.log('[CreateLobbyBtn] Creating local lobby');
          const code = genCode();
          const store = getLobbyStore();
          if (!store[code]) { store[code] = { players: [] }; setLobbyStore(store); }
          navigateToLobby(code);
        }
      });
      joinBtn?.addEventListener('click', ()=>{
        updateSelfNameFromInput();
        const raw = (joinCodeInput?.value||'').toUpperCase().trim();
        const code = raw.replace(/[^A-Z0-9]/g,'').slice(0,8);
        console.log('[JoinBtn] Clicked. code:', code, 'wsConnected:', wsConnected, 'ws:', ws);
        if (!code) { console.log('[JoinBtn] No code entered'); return; }
        if (wsConnected && ws) {
          console.log('[JoinBtn] Sending join lobby to server');
          ws.send(JSON.stringify({ type: 'join', code, name: selfName }));
        } else {
          console.log('[JoinBtn] Joining local lobby');
          navigateToLobby(code);
        }
      });
      startGameBtn?.addEventListener('click', ()=>{
        if (wsConnected && ws) ws.send(JSON.stringify({ type: 'start' }));
        else showGame();
      });
      leaveLobbyBtn?.addEventListener('click', ()=>{
        console.log('[LeaveLobbyBtn] Clicked. wsConnected:', wsConnected, 'ws:', ws);
        if (wsConnected && ws) {
          console.log('[LeaveLobbyBtn] Sending leave lobby to server');
          ws.send(JSON.stringify({ type: 'leave' }));
        }
        leaveLobby();
      });

      // Deep link support: if URL has a code, join that lobby
      window.addEventListener('DOMContentLoaded', ()=>{
        const url = getDefaultWsUrl();
        if (url) connectWS(url);
        const code = (location.hash||'').replace('#','').trim();
        if (code) {
          if (wsConnected && ws) {
            ws.send(JSON.stringify({ type: 'join', code, name: selfName }));
          } else {
            renderLobby(code);
            showLobby();
            addPlayerToLobby(code, selfName);
          }
        } else { showMenu(); }
        // Wire stats modal and debug after initial DOM ready
        try {
          statsBtn?.addEventListener('click', ()=>{
            if (statsModal) statsModal.style.display = 'grid';
            // Request latest stats from server
            if (wsConnected && ws) {
              try { ws.send(JSON.stringify({ type: 'getStats' })); } catch {}
            }
          });
          closeStats?.addEventListener('click', ()=>{ if (statsModal) statsModal.style.display = 'none'; });
          // Click outside to close
          statsModal?.addEventListener('click', (e)=>{ if (e.target === statsModal) statsModal.style.display = 'none'; });

          // Debug dropdown logic
          const debugDropdown = document.getElementById('debugDropdown');
          const debugDropdownWrap = document.getElementById('debugDropdownWrap');
          const debugDrawJokers = document.getElementById('debugDrawJokers');
          const debugDrawFaces = document.getElementById('debugDrawFaces');
          const debugRefreshBalance = document.getElementById('debugRefreshBalance');
          const debugSetHealth = document.getElementById('debugSetHealth');

          // Show/hide dropdown on debugBtn click
          debugBtn?.addEventListener('click', (e)=>{
            e.stopPropagation();
            if (debugDropdown.style.display === 'block') {
              debugDropdown.style.display = 'none';
            } else {
              debugDropdown.style.display = 'block';
            }
          });
          // Hide dropdown on outside click
          document.addEventListener('click', (e)=>{
            if (!debugDropdownWrap.contains(e.target)) debugDropdown.style.display = 'none';
          });

          // Draw 3 Jokers and play them
          debugDrawJokers?.addEventListener('click', ()=>{
            debugDropdown.style.display = 'none';
            if (cardsEl) {
              cardsEl.innerHTML = '';
              const newCards = [];
              for (let i = 0; i < 3; i++) {
                const el = renderCard({ r: 'Joker', s: 'JOKER' });
                cardsEl.appendChild(el);
                newCards.push(el);
              }
              const thisRun = ++runToken;
              useCardsSequentially(newCards, thisRun).then(() => { finalizePrize && finalizePrize(); });
            }
          });
          // Draw 3 random face cards and play them
          debugDrawFaces?.addEventListener('click', ()=>{
            debugDropdown.style.display = 'none';
            if (cardsEl) {
              cardsEl.innerHTML = '';
              const faces = ['J','Q','K'];
              const suits = ['spade','heart','diamond','club'];
              const newCards = [];
              for (let i = 0; i < 3; i++) {
                const r = faces[Math.floor(Math.random()*faces.length)];
                const s = suits[Math.floor(Math.random()*suits.length)];
                let cardObj = { r, s: s==='spade'?'♠':s==='heart'?'♥':s==='diamond'?'♦':'♣' };
                const el = renderCard(cardObj);
                cardsEl.appendChild(el);
                newCards.push(el);
              }
              const thisRun = ++runToken;
              useCardsSequentially(newCards, thisRun).then(() => { finalizePrize && finalizePrize(); });
            }
          });
          // Refresh balance to £100
          debugRefreshBalance?.addEventListener('click', ()=>{
            debugDropdown.style.display = 'none';
            balance = 100;
            if (balanceEl) balanceEl.textContent = `£${balance}`;
          });
          // Owner-only: Set monster health to 100
          debugSetHealth?.addEventListener('click', ()=>{
            debugDropdown.style.display = 'none';
            if (!(selfId && ownerId && String(selfId) === String(ownerId))) return;
            if (wsConnected && ws) { try { ws.send(JSON.stringify({ type: 'debugSetHealth', health: 100 })); } catch {} }
            else { progress = Math.min(goal, 100); const pct = goal>0 ? progress/goal : 0; progressFill.style.width = `${pct*100}%`; progressLabel.textContent = `${progress} / ${goal}`; }
          });
        } catch {}
        // Jackpot modal wiring
        try {
          closeJackpot?.addEventListener('click', ()=>{ if (jackpotModal) jackpotModal.style.display = 'none'; });
          jackpotModal?.addEventListener('click', (e)=>{ if (e.target === jackpotModal) jackpotModal.style.display = 'none'; });
        } catch {}
      });

      // Minimal interaction scaffold
  const buyBtn = document.getElementById('buyBtn');
      const balanceEl = document.querySelector('#balance .value');
      const prizeEl = document.querySelector('#prize .value');
      const cardsEl = document.getElementById('cards');
  const progressFill = document.getElementById('progressFill');
  const progressLabel = document.getElementById('progressLabel');
  const levelBadge = document.getElementById('levelBadge');
  const characterArea = document.getElementById('characterArea');
  const player = document.getElementById('player');
  const playerRectEl = document.getElementById('playerRect');
  const jackpotEl = document.getElementById('jackpot');
  const statsBtn = document.getElementById('statsBtn');
  const debugBtn = document.getElementById('debugBtn');
  const statsModal = document.getElementById('statsModal');
  const closeStats = document.getElementById('closeStats');
  const leaderTop = document.getElementById('leaderTop');
  const myRankEl = document.getElementById('myRank');
  const recycleBtn = document.getElementById('recycleBtn');
  const playerHpEl = document.getElementById('playerHp');
  // Track the currently selected monster for jackpot contributions
  let currentMonster = null;
      let balance = 100;
      let prize = 0;
  let progress = 18000;
  let goal = 20000;
  let jackpot = 1000;
  let runToken = 0; // cancels pending sequences on new buys
  const supportsWAAPI = typeof Element !== 'undefined' && Element.prototype && typeof Element.prototype.animate === 'function';
      const stakeSteps = [0.1, 0.2, 0.5, 1, 2];
      let stakeIndex = 3; // £1 default
      let stake = stakeSteps[stakeIndex];
  const playerMaxHp = 50;
  let playerHp = playerMaxHp;
  // Stats counters (local)
  let statHearts = 0;
  let statClubs = 0;
  let statSpades = 0;
  let statDiamonds = 0;
  let statPrizes = 0; // currency total
  let statDamage = 0; // total damage dealt
  function updateStatsCounters(){
    const h = document.getElementById('statHearts'); if (h) h.textContent = String(statHearts);
    const c = document.getElementById('statClubs'); if (c) c.textContent = String(statClubs);
    const s = document.getElementById('statSpades'); if (s) s.textContent = String(statSpades);
    const d = document.getElementById('statDiamonds'); if (d) d.textContent = String(statDiamonds);
    const p = document.getElementById('statPrizes'); if (p) p.textContent = formatCurrency(statPrizes);
    const dm = document.getElementById('statDamage'); if (dm) dm.textContent = String(statDamage);
  }
  // Owner id from server (roster)
  let ownerId = null;

      const stakeMinusBtn = document.getElementById('stakeMinus');
      const stakePlusBtn = document.getElementById('stakePlus');

      function formatStake(s) { return s < 1 ? `${Math.round(s*100)}p` : `£${s}`; }
      function formatCurrency(v) {
        const n = Number(v) || 0;
        if (n === 0) return '£0';
        if (Math.abs(n) < 1) return `${Math.round(n * 100)}p`;
        // Show whole pounds without decimals, otherwise 2dp
        return Number.isInteger(n) ? `£${n}` : `£${n.toFixed(2)}`;
      }
      function updateStakeDisplay(){
        const small = document.querySelector('#buyBtn small');
        if (small) small.textContent = formatStake(stake);
      }
      function updateJackpotDisplay(){
        if (!jackpotEl) return;
        const text = `${formatCurrency(jackpot)}`;
        jackpotEl.textContent = text;
      }
      // Defeat UX elements and state
      const defeatBanner = document.getElementById('defeatBanner');
      const jackpotModal = document.getElementById('jackpotModal');
      const closeJackpot = document.getElementById('closeJackpot');
      const jackpotAwardAmount = document.getElementById('jackpotAwardAmount');
  let monsterDefeated = false;
  let defeatCountdownTimer = null;
      function showDefeatSequence(){
        const img = document.getElementById('monsterSprite');
        if (!img || monsterDefeated) return;
        monsterDefeated = true;
        try {
          const fade = img.animate([{ opacity: 1 }, { opacity: 0 }], { duration: 700, easing: 'ease' });
          fade.finished.then(()=>{ img.style.opacity = '0'; }).catch(()=>{ img.style.opacity = '0'; });
        } catch { img.style.transition = 'opacity 700ms ease'; img.style.opacity = '0'; }
        if (defeatBanner) {
          defeatBanner.style.display = 'flex';
          try { defeatBanner.animate([{ opacity: 0, transform: 'scale(0.98)' }, { opacity: 1, transform: 'scale(1)' }], { duration: 280, easing: 'ease-out', fill: 'forwards' }); }
          catch { defeatBanner.style.opacity = '1'; }
        }
        setTimeout(()=>{
          if (jackpotModal) {
            if (jackpotAwardAmount) jackpotAwardAmount.textContent = formatCurrency(jackpot);
            jackpotModal.style.display = 'grid';
          }
        }, 800);
        // Start a 10s countdown to next monster
        const header = document.querySelector('header.progress-wrap');
        const countdown = document.createElement('div');
        countdown.id = 'defeatCountdown';
        countdown.style.position = 'absolute';
        countdown.style.top = '6px';
        countdown.style.right = '12px';
        countdown.style.background = 'rgba(2,6,23,0.8)';
        countdown.style.border = '1px solid rgba(148,163,184,0.35)';
        countdown.style.borderRadius = '999px';
        countdown.style.padding = '4px 10px';
        countdown.style.fontWeight = '800';
        countdown.style.fontSize = '0.85rem';
        countdown.style.color = '#fde68a';
        countdown.textContent = 'Next monster in 10s';
        header?.appendChild(countdown);
        let remaining = 10;
        defeatCountdownTimer = setInterval(async ()=>{
          remaining -= 1;
          if (countdown) countdown.textContent = `Next monster in ${remaining}s`;
          if (remaining <= 0) {
            clearInterval(defeatCountdownTimer); defeatCountdownTimer = null;
            countdown?.remove();
            // Only the lobby owner picks and broadcasts the next monster
            if (selfId && ownerId && String(selfId) === String(ownerId)) {
              try {
                const currentSrc = img.getAttribute('src');
                const nextMonster = await pickRandomMonsterFromJson(currentSrc);
                if (nextMonster && nextMonster.image) {
                  const nextLevel = Number((Number(nextMonster.level) || 1) + 1);
                  img.setAttribute('src', String(nextMonster.image));
                  if (nextMonster.name) img.setAttribute('alt', String(nextMonster.name));
                  currentMonster = { ...nextMonster, level: nextLevel };
                  updateMonsterUI({ level: nextLevel, health: Number(nextMonster.health) || goal });
                  img.style.opacity = '1';
                  const key = (nextMonster && (nextMonster.name || nextMonster.image)) ? String(nextMonster.name || nextMonster.image) : 'default';
                  currentMonsterKey = key;
                  if (wsConnected && ws) { try { ws.send(JSON.stringify({ type: 'setMonster', key })); } catch {} }
                  else pendingMonsterKey = key;
                  // Replenish all players to full HP
                  const selfUnit = document.getElementById('player');
                  if (selfUnit) { applyHealToPlayer(selfId || 'self', 9999); }
                  const remotes = Array.from(document.querySelectorAll('[data-player-id]'));
                  for (const el of remotes) { const id = el.getAttribute('data-player-id'); if (id) applyHealToPlayer(id, 9999); }
                  resetDefeatUX();
                }
              } catch {}
            }
            // All other clients just wait for the monsterSet event from the server
          }
        }, 1000);
      }
      function resetDefeatUX(){
        const img = document.getElementById('monsterSprite');
        if (img) img.style.opacity = '1';
        if (defeatBanner) { defeatBanner.style.display = 'none'; defeatBanner.style.opacity = '0'; }
        const cd = document.getElementById('defeatCountdown'); if (cd) cd.remove();
        if (defeatCountdownTimer) { try { clearInterval(defeatCountdownTimer); } catch {} defeatCountdownTimer = null; }
        monsterDefeated = false;
      }
      function updatePlayerHp(){ if (playerHpEl) playerHpEl.textContent = `${playerHp} / ${playerMaxHp}`; }
      updateStakeDisplay();
      updateJackpotDisplay();
      updatePlayerHp();

      // Load monsters from JSON and initialize starting monster (random level 1)
      async function initStartMonster() {
        try {
          const res = await fetch('assets/monsters.json');
          if (!res.ok) throw new Error('Failed to load monsters.json');
          const monsters = await res.json();
          if (!Array.isArray(monsters) || monsters.length === 0) return;
          const level1 = monsters.filter(m => Number(m.level) === 1);
          const pool = level1.length > 0 ? level1 : monsters;
          const pick = pool[Math.floor(Math.random() * pool.length)];
          // Set sprite image if available
          const img = document.getElementById('monsterSprite');
          if (img && pick && pick.image) {
            img.setAttribute('src', String(pick.image));
            if (pick.name) img.setAttribute('alt', String(pick.name));
          }
          // Align UI (level badge, progress/goal)
          currentMonster = pick;
          updateMonsterUI({ level: Number(pick.level) || 1, health: Number(pick.health) || goal });
          // Inform server of current monster key (use image or name as stable key)
          const key = (pick && (pick.name || pick.image)) ? String(pick.name || pick.image) : 'default';
          currentMonsterKey = key;
          if (wsConnected && ws) { try { ws.send(JSON.stringify({ type: 'setMonster', key })); } catch {} }
          else pendingMonsterKey = key;
        } catch (e) {
          // If fetch fails, keep existing defaults
          // No-op
        }
      }

      // Monster recycle logic — pick a random monster from monsters.json and sync health/level
      async function pickRandomMonsterFromJson(currentSrc) {
        try {
          const res = await fetch('assets/monsters.json');
          if (!res.ok) throw new Error('Failed to load monsters.json');
          const monsters = await res.json();
          if (!Array.isArray(monsters) || monsters.length === 0) return null;
          // Avoid picking same image consecutively
          const pool = monsters.filter(m => !currentSrc || !String(currentSrc).endsWith(String(m.image)));
          const list = pool.length > 0 ? pool : monsters;
          const idx = Math.floor(Math.random() * list.length);
          return list[idx];
        } catch {
          return null;
        }
      }
      recycleBtn?.addEventListener('click', async () => {
        const img = document.getElementById('monsterSprite');
        if (!img) return;
        const current = img.getAttribute('src') || '';
        const nextMonster = await pickRandomMonsterFromJson(current);
        if (nextMonster && nextMonster.image) {
          img.setAttribute('src', String(nextMonster.image));
          if (nextMonster.name) img.setAttribute('alt', String(nextMonster.name));
          currentMonster = nextMonster;
          updateMonsterUI({ level: Number(nextMonster.level) || 1, health: Number(nextMonster.health) || goal });
          const key = (nextMonster && (nextMonster.name || nextMonster.image)) ? String(nextMonster.name || nextMonster.image) : 'default';
          currentMonsterKey = key;
          if (wsConnected && ws) { try { ws.send(JSON.stringify({ type: 'setMonster', key })); } catch {} }
          else pendingMonsterKey = key;
        }
        // Small feedback
        img.classList.add('shake');
        setTimeout(() => img.classList.remove('shake'), 320);
      });
      stakeMinusBtn?.addEventListener('click', (e)=>{
        e.preventDefault();
        if (stakeIndex > 0) { stakeIndex--; stake = stakeSteps[stakeIndex]; updateStakeDisplay(); }
      });
      stakePlusBtn?.addEventListener('click', (e)=>{
        e.preventDefault();
        if (stakeIndex < stakeSteps.length - 1) { stakeIndex++; stake = stakeSteps[stakeIndex]; updateStakeDisplay(); }
      });

      function enableBuy(){
        buyBtn.disabled = false;
        buyBtn.removeAttribute('aria-disabled');
      }

      function handleBuy() {
        if (buyBtn.disabled) return;
        if (balance <= 0) return;
        buyBtn.disabled = true;
        buyBtn.setAttribute('aria-disabled', 'true');
        // Deduct stake (supports pence)
        balance = Math.max(0, Number((balance - stake).toFixed(2)));
        balanceEl.textContent = `£${balance}`;
  prizeEl.textContent = formatCurrency(prize);

        // Contribute stake * jackpotPercent to shared jackpot (server if connected)
        if (currentMonster && typeof currentMonster.jackpotPercent !== 'undefined') {
          const jpPct = Math.max(0, Number(currentMonster.jackpotPercent) || 0);
          const contrib = Number(((stake * jpPct) / 100).toFixed(2));
          if (contrib > 0) {
            if (wsConnected && ws) {
              try { ws.send(JSON.stringify({ type: 'jackpotContribute', amount: contrib })); } catch {}
            } else {
              jackpot = Number((jackpot + contrib).toFixed(2));
              updateJackpotDisplay();
            }
          }
        }

        // Draw cards
        cardsEl.innerHTML = '';
        let newCards = drawThreeCards(cardsEl);
        if (!Array.isArray(newCards)) newCards = Array.from(cardsEl.querySelectorAll('.card'));

          const thisRun = ++runToken;
          setTimeout(() => {
            if (thisRun !== runToken) return;
            const seq = useCardsSequentially(Array.isArray(newCards) ? newCards : [], thisRun);
            seq.then(() => { finalizePrize(); enableBuy(); }).catch(() => { finalizePrize(); enableBuy(); });
          }, 1000);

        // No auto progress change
      }
      // Use pointer events to handle both mouse and touch reliably
      buyBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if (!buyBtn.disabled) handleBuy();
      }, { passive: false });

      // Initial render of progress reflecting the text exactly
      (function initProgress(){
            const pct = progress / goal;
            progressFill.style.width = `${pct * 100}%`;
            // Default label shows monster name; will be updated when monster changes
            // progressLabel.textContent already set in HTML; keep in sync with current sprite if needed
          })();

          // Initialize starting monster after DOM is ready
          window.addEventListener('DOMContentLoaded', () => {
            initStartMonster();
          });

          function updateMonsterUI(monster){
            // monster: { name, level, health }
            if (monster && typeof monster.health === 'number') {
              progress = monster.health; // start full health
              goal = monster.health;     // set goal to monster's max health
            }
            if (monster && typeof monster.level === 'number' && levelBadge) {
              levelBadge.textContent = String(monster.level);
            }
            const pct = progress / goal;
            progressFill.style.width = `${pct * 100}%`;
            // Always show numeric HP current/total
            progressLabel.textContent = `${progress} / ${goal}`;
          }

      // Character placement: horizontal drag within the character area
      (function initCharacterDrag(){
        if (!characterArea || !player || !playerRectEl) return;
        // Center horizontally by default
        centerPlayer();
        let dragging = false;
        function clamp(x){
          const areaRect = characterArea.getBoundingClientRect();
          const rectW = playerRectEl.getBoundingClientRect().width;
          const minX = rectW/2; // because we translateX(-50%)
          const maxX = areaRect.width - rectW/2;
          return Math.max(minX, Math.min(maxX, x));
        }
        function centerPlayer(){
          const areaRect = characterArea.getBoundingClientRect();
          const rectW = playerRectEl.getBoundingClientRect().width;
          const x = areaRect.width / 2;
          player.style.left = x + 'px';
          // Share initial centered position with others
          try {
            if (wsConnected && ws) {
              const xn = Math.max(0, Math.min(1, (x - rectW/2) / (areaRect.width - rectW)));
              ws.send(JSON.stringify({ type: 'playerPos', x: xn }));
            }
          } catch {}
        }
        function toLocalX(evt){
          const areaRect = characterArea.getBoundingClientRect();
          const pageX = (evt.touches && evt.touches[0] ? evt.touches[0].clientX : evt.clientX);
          return pageX - areaRect.left;
        }
        const start = (e)=>{
          e.preventDefault(); dragging = true;
          document.addEventListener('pointermove', move, { passive:false });
          document.addEventListener('pointerup', end, { passive:false, once:true });
        };
        const move = (e)=>{
          if (!dragging) return;
          const localX = toLocalX(e);
          const x = clamp(localX);
          player.style.left = x + 'px';
          // Broadcast normalized position 0..1
          try {
            if (wsConnected && ws) {
              const areaRect = characterArea.getBoundingClientRect();
              const rectW = playerRectEl.getBoundingClientRect().width;
              const xn = Math.max(0, Math.min(1, (x - rectW/2) / (areaRect.width - rectW)));
              ws.send(JSON.stringify({ type: 'playerPos', x: xn }));
            }
          } catch {}
        };
        const end = ()=>{ dragging = false; document.removeEventListener('pointermove', move); };
        playerRectEl.addEventListener('pointerdown', start, { passive:false });
        window.addEventListener('resize', centerPlayer);
      })();

      // Draw returns list of card elements
      function drawThreeCards(container) {
        const deck = buildDeck();
        const created = [];
        // Pick 3 random cards
        for (let i = 0; i < 3; i++) {
          // 5% chance to draw a Joker card
          const roll = Math.random();
          let el;
          if (roll < 0.05) {
            el = renderCard({ r: 'Joker', s: 'JOKER' });
          } else {
            const idx = Math.floor(Math.random() * deck.length);
            const card = deck.splice(idx, 1)[0];
            el = renderCard(card);
          }
          container.appendChild(el);
          created.push(el);
        }
        return created;
      }

      // Sequentially "use" cards: move up 30px, wait 1s, return, then discard
      async function useCardsSequentially(cards, token) {
        if (!Array.isArray(cards) || cards.length === 0) return;
        const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        for (const el of cards) {
          if (token !== runToken) return; // cancelled
          if (!reduceMotion) {
            try { await useCard(el); } catch {}
            if (token !== runToken) return; // cancelled
            // Discard animation (WAAPI or CSS fallback)
            if (supportsWAAPI) {
              const discard = el.animate([
                { opacity: 1, transform: 'translateY(0) scale(1)' },
                { opacity: 0, transform: 'translateY(10px) scale(0.98)' }
              ], { duration: 250, easing: 'ease', fill: 'forwards' });
              try { await discard.finished; } catch {}
            } else {
              el.style.transition = 'transform 250ms ease, opacity 250ms ease';
              el.style.transform = 'translateY(10px) scale(0.98)';
              el.style.opacity = '0';
              await sleep(260);
            }
          }
          // Keep the card's layout space to avoid shifting: hide instead of remove
          el.style.opacity = '0';
          el.style.visibility = 'hidden';
          el.style.transform = 'translateY(0)';
        // Spawn bright red particles from monster to each target
        try {
          const sprite = document.getElementById('monsterSprite');
          const effects = document.getElementById('effects');
          if (sprite && effects) {
            const rectM = sprite.getBoundingClientRect();
            for (const id of targets) {
              const unit = id === (selfId || 'self') ? document.getElementById('player') : document.querySelector(`[data-player-id="${id}"]`);
              if (!unit) continue;
              const rectU = unit.getBoundingClientRect();
              const startX = rectM.left + rectM.width / 2;
              const startY = rectM.top + rectM.height * 0.3;
              const endX = rectU.left + rectU.width / 2;
              const endY = rectU.top + 10;
              // Create a handful of particles
              for (let i = 0; i < 12; i++) {
                const p = document.createElement('div');
                p.style.position = 'fixed';
                p.style.left = `${startX}px`;
                p.style.top = `${startY}px`;
                p.style.width = '6px';
                p.style.height = '6px';
                p.style.borderRadius = '999px';
                p.style.background = '#ff1a1a'; // bright red
                p.style.boxShadow = '0 0 8px rgba(255,26,26,0.8)';
                p.style.opacity = '0.95';
                effects.appendChild(p);
                const dx = endX - startX;
                const dy = endY - startY;
                const jitterX = (Math.random() - 0.5) * 20;
                const jitterY = (Math.random() - 0.5) * 10;
                const keyframes = [
                  { transform: 'translate(0,0)', opacity: 0.9 },
                  { transform: `translate(${dx * 0.6 + jitterX}px, ${dy * 0.6 + jitterY}px)`, opacity: 1 },
                  { transform: `translate(${dx}px, ${dy}px)`, opacity: 0 }
                ];
                const duration = 520 + Math.random() * 280;
                const easing = 'cubic-bezier(0.22, 1, 0.36, 1)';
                const anim = p.animate(keyframes, { duration, easing, fill: 'forwards' });
                anim.finished.catch(()=>{}).finally(()=>{ p.remove(); });
              }
            }
          }
        } catch {}
        }
      }

  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function forceReflow(el){ void el.offsetWidth; }

      async function useCard(el) {
        const upPx = window.matchMedia('(max-width: 767px)').matches ? 60 : 30;
        try {
          const suit = el.dataset.suit || 'spade';
          if (suit === 'joker') {
            // Joker triggers monster attack on players
            if (wsConnected && ws) {
              try { ws.send(JSON.stringify({ type: 'jokerAttackRequest' })); } catch {}
            }
          } else {
            // Avoid double particles for host: only spawn local particles if action isn't broadcasted from self
            const actingId = selfId || 'self';
            // When we send to server, we'll receive a broadcast including our own 'by' id.
            // Here we limit local spawn; remote effects will render via WS handlers.
            spawnCardParticlesFromPlayer(suit);
          }
        } catch {}
        let effectInfo = null;
        try {
          const suit = el.dataset.suit || 'spade';
          // Use stored rank instead of parsing text
          const rankText = el.dataset.rank || '';
          const value = rankToValue(rankText);
          effectInfo = applyCardEffect(suit, value, rankText);
        } catch {}
        const tag = el.querySelector('.tag');
        if (tag) {
          const suit = el.dataset.suit || 'spade';
          const label = suitLabel(suit);
          let amountText = '';
          if (effectInfo && typeof effectInfo.amount !== 'undefined') {
            if (suit === 'diamond') amountText = ` ${formatCurrency(effectInfo.amount)}`; else amountText = ` ${effectInfo.amount}`;
          }
          tag.textContent = `${label}${amountText}`;
        }
        if (supportsWAAPI) {
          const suitForAnim = el.dataset.suit || 'spade';
          if (suitForAnim === 'joker') {
            // Down-then-up animation for Joker
            const down1 = el.animate([
              { transform: 'translateY(0px)' },
              { transform: `translateY(${upPx}px)` }
            ], { duration: 300, easing: 'ease-out', fill: 'forwards' });
            if (tag) tag.style.opacity = '1';
            try { await down1.finished; } catch {}
            await sleep(0);
            const up1 = el.animate([
              { transform: `translateY(${upPx}px)` },
              { transform: 'translateY(0px)' }
            ], { duration: 300, easing: 'ease-in', fill: 'forwards' });
            try { await up1.finished; } catch {}
            if (tag) tag.style.opacity = '0';
          } else {
            // Default up-then-down
            const up = el.animate([
              { transform: 'translateY(0px)' },
              { transform: `translateY(-${upPx}px)` }
            ], { duration: 300, easing: 'ease-out', fill: 'forwards' });
            if (tag) tag.style.opacity = '1';
            try { await up.finished; } catch {}
            await sleep(0);
            const down = el.animate([
              { transform: `translateY(-${upPx}px)` },
              { transform: 'translateY(0px)' }
            ], { duration: 300, easing: 'ease-in', fill: 'forwards' });
            try { await down.finished; } catch {}
            if (tag) tag.style.opacity = '0';
          }
        } else {
          // CSS transition fallback
          const suitForAnim = el.dataset.suit || 'spade';
          el.style.transition = 'transform 300ms ease-out';
          el.style.transform = 'translateY(0px)';
          forceReflow(el);
          if (suitForAnim === 'joker') {
            el.style.transform = `translateY(${upPx}px)`;
          } else {
            el.style.transform = `translateY(-${upPx}px)`;
          }
          if (tag) tag.style.opacity = '1';
          await sleep(320);
          await sleep(0);
          el.style.transition = 'transform 300ms ease-in';
          el.style.transform = 'translateY(0px)';
          await sleep(320);
          if (tag) tag.style.opacity = '0';
        }
      }

      function suitLabel(suit) {
        switch (suit) {
          case 'spade': return 'Damage';
          case 'diamond': return 'Prize';
          case 'heart': return 'Heal';
          case 'club': return 'Damage';
          case 'joker': return 'Attack';
          default: return '';
        }
      }

      function buildDeck() {
        const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const suits = ['♠','♥','♦','♣'];
        const deck = [];
        for (const r of ranks) {
          for (const s of suits) {
            deck.push({ r, s });
          }
        }
        return deck;
      }

      function renderCard(card) {
        const el = document.createElement('div');
        el.className = 'card';
        // Joker special handling
        if (card && card.r === 'Joker') {
          el.dataset.suit = 'joker';
          el.dataset.rank = 'Joker';
          el.innerHTML = `
            <span class="corner tl">Jkr<br>🃏</span>
            <span class="center">🃏</span>
            <span class="corner br">Jkr<br>🃏</span>
            <span class="tag" aria-hidden="true"></span>
          `;
          el.style.setProperty('--card-ink', '#a78bfa');
          el.style.setProperty('--card-bg', 'rgba(255,255,255,0.98)');
          return el;
        }
        const suitMap = { '♠': 'spade', '♥': 'heart', '♦': 'diamond', '♣': 'club' };
        el.dataset.suit = suitMap[card.s] || 'spade';
        // Store explicit rank to avoid parsing issues
        el.dataset.rank = String(card.r);
        el.innerHTML = `
          <span class="corner tl">${card.r}<br>${card.s}</span>
          <span class="center">${card.s}</span>
          <span class="corner br">${card.r}<br>${card.s}</span>
          <span class="tag" aria-hidden="true"></span>
        `;
  // Color hearts/diamonds red ink, spades/clubs dark ink
  const red = card.s === '♥' || card.s === '♦';
  el.style.setProperty('--card-ink', red ? '#ef4444' : '#111827');
        return el;
      }

      // Map rank string to numeric value for effects
      function rankToValue(rank) {
        const r = String(rank).trim();
        if (r === 'A') return 14; // Ace high
        if (r === 'K') return 13;
        if (r === 'Q') return 12;
        if (r === 'J') return 11;
        const n = parseInt(r, 10);
        return isNaN(n) ? 0 : n;
      }

      // Apply per-suit card effects to monster health (progress) and prize
  function applyCardEffect(suit, value, rankText) {
        const v = Math.max(0, Number(value) || 0);
        const isFace = (rankText === 'J' || rankText === 'Q' || rankText === 'K');
        const critBonus = rankText === 'J' ? 1 : rankText === 'Q' ? 2 : rankText === 'K' ? 3 : 0;
        const critDamage = 10 + critBonus;
        let amountApplied = 0;
        let label = '';
        if (suit === 'spade') {
          const base = isFace ? critDamage : v;
          const mult = (stake >= 2 ? 2 : 1);
          const dmg = Math.max(0, Math.floor(base * mult));
          amountApplied = dmg;
          label = 'Damage';
          statSpades++; statDamage += dmg; updateStatsCounters();
          // Play slash-attack overlay for face card crits
          if (isFace) {
            if (typeof playSlashAttackOverlay === 'function') playSlashAttackOverlay();
            if (wsConnected && ws) {
              try { ws.send(JSON.stringify({ type: 'slashAttackOverlay' })); } catch {}
            }
          }
          if (wsConnected && ws) {
            try { ws.send(JSON.stringify({ type: 'damageMonster', amount: dmg, suit: 'spade' })); } catch {}
          } else {
            progress = Math.max(0, progress - dmg);
            monsterFeedback('damage');
          }
          if (progress <= 0) { showDefeatSequence(); }
        } else if (suit === 'diamond') {
          // Face card shared prize logic
          const isNumberCard = /^(?:2|3|4|5|6|7|8|9|10)$/.test(rankText);
          let turnPrize = 0;
          let sharedPrize = 0;
          let selfPrize = 0;
          let othersPrize = 0;
          let othersCount = 0;
          let othersNames = [];
          if (rankText === 'A') {
            turnPrize = Number((5 * stake).toFixed(2));
            selfPrize = turnPrize;
          } else if (isNumberCard) {
            turnPrize = Number(((v / 10) * stake).toFixed(2));
            selfPrize = turnPrize;
          } else if (rankText === 'J') {
            sharedPrize = Number((3 * stake).toFixed(2));
            selfPrize = Number((2 * stake).toFixed(2));
            othersPrize = Number((1 * stake).toFixed(2));
            othersCount = 1;
          } else if (rankText === 'Q') {
            sharedPrize = Number((6 * stake).toFixed(2));
            selfPrize = Number((4 * stake).toFixed(2));
            othersPrize = Number((1 * stake).toFixed(2));
            othersCount = 2;
          } else if (rankText === 'K') {
            sharedPrize = Number((9 * stake).toFixed(2));
            selfPrize = Number((6 * stake).toFixed(2));
            othersPrize = Number((1 * stake).toFixed(2));
            othersCount = 3;
          }
          if (selfPrize > 0) {
            prize = Number((prize + selfPrize).toFixed(2));
            prizeEl.textContent = formatCurrency(prize);
            statDiamonds++; statPrizes = Number((statPrizes + selfPrize).toFixed(2)); updateStatsCounters();
            // Do NOT show notification for self-earned prize
          }
          if (othersPrize > 0 && othersCount > 0) {
            // Pick random other players (never include self)
            let ids = Array.from(lobbyPlayers.keys()).filter(id => id !== (selfId || 'self'));
            if (ids.length > 0) {
              for (let i = ids.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); const t = ids[i]; ids[i] = ids[j]; ids[j] = t; }
              const targets = ids.slice(0, Math.min(othersCount, ids.length));
              // Send sharePrize event to server for networked players
              if (wsConnected && ws && targets.length > 0) {
                try {
                  // Send both id and name for each target
                  const to = targets.map(id => ({ id, name: (lobbyPlayers.get(id)?.name || id) }));
                  ws.send(JSON.stringify({ type: 'sharePrize', amount: othersPrize, to }));
                } catch {}
              }
              // Never show shared notification for self
            }
          }
          if (sharedPrize > 0) {
            amountApplied = sharedPrize;
          } else {
            amountApplied = selfPrize;
          }
          label = 'Prize';
        } else if (suit === 'heart') {
          // Hearts: special face-card rules and fallback to numeric formula
          const isNumberCard = /^(?:2|3|4|5|6|7|8|9|10)$/.test(rankText);
          let selfHeal = 0;
          let othersHeal = 0;
          let othersCount = 0;
          if (rankText === 'J') {
            selfHeal = 5; othersHeal = 2; othersCount = 2;
          } else if (rankText === 'Q') {
            selfHeal = 10; othersHeal = 4; othersCount = 4;
          } else if (rankText === 'K') {
            selfHeal = 15; othersHeal = 6; othersCount = 6;
          } else {
            // Non-face and Ace cards follow currency-based formula converted to HP
            let healValueCurrency;
            if (rankText === 'A') {
              healValueCurrency = Number((5 * stake).toFixed(2));
            } else if (isNumberCard) {
              healValueCurrency = Number(((v / 10) * stake).toFixed(2));
            } else {
              healValueCurrency = 0;
            }
            selfHeal = Math.max(0, Math.round(healValueCurrency));
            othersHeal = 0; othersCount = 0; // no group heal for non-face
          }
          amountApplied = selfHeal; // report primary effect amount
          statHearts++; updateStatsCounters();
          // Apply self heal
          if (selfHeal > 0) {
            if (wsConnected && ws) {
              try { ws.send(JSON.stringify({ type: 'healPlayer', id: selfId || 'self', amount: selfHeal })); } catch {}
            } else {
              applyHealToPlayer(selfId || 'self', selfHeal);
              spawnHeartRingForPlayer(selfId || 'self');
            }
          }
          // Apply others heal (random subset, never include self)
          if (othersHeal > 0 && othersCount > 0) {
            let ids = Array.from(lobbyPlayers.keys()).filter(id => id !== (selfId || 'self'));
            if (ids.length > 0) {
              for (let i = ids.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); const t = ids[i]; ids[i] = ids[j]; ids[j] = t; }
              const targets = ids.slice(0, Math.min(othersCount, ids.length));
              if (wsConnected && ws) {
                try { ws.send(JSON.stringify({ type: 'heartHealRequest', amount: othersHeal, count: targets.length, to: targets })); } catch {}
              } else {
                for (const id of targets) {
                  applyHealToPlayer(id, othersHeal);
                  spawnHeartRingForPlayer(id);
                }
              }
              // Never show shared notification for self
            }
          }
          label = 'Heal';
        } else if (suit === 'club') {
          const base = isFace ? critDamage : v;
          const mult = (stake >= 2 ? 2 : 1);
          const dmg = Math.max(0, Math.floor(base * mult));
          amountApplied = dmg;
          label = 'Damage';
          statClubs++; statDamage += dmg; updateStatsCounters();
          // Play slash-attack overlay for face card crits
          if (isFace) {
            if (typeof playSlashAttackOverlay === 'function') playSlashAttackOverlay();
            if (wsConnected && ws) {
              try { ws.send(JSON.stringify({ type: 'slashAttackOverlay' })); } catch {}
            }
          }
          if (wsConnected && ws) {
            try { ws.send(JSON.stringify({ type: 'damageMonster', amount: dmg, suit: 'club' })); } catch {}
          } else {
            progress = Math.max(0, progress - dmg);
            monsterFeedback('damage');
          }
          if (progress <= 0) { showDefeatSequence(); }
        }
// Listen for slash-attack overlay events from network
if (typeof ws !== 'undefined' && ws) {
  ws.addEventListener('message', function(e) {
    try {
      const msg = JSON.parse(e.data);
      if (msg && msg.type === 'slashAttackOverlay') {
        if (typeof playSlashAttackOverlay === 'function') playSlashAttackOverlay();
      }
    } catch {}
  });
}
        const pct = progress / goal;
        progressFill.style.width = `${pct * 100}%`;
        progressLabel.textContent = `${progress} / ${goal}`;
        return { label, amount: amountApplied };
      }

  function finalizePrize() {
    if (prize > 0) {
      balance = Number((balance + prize).toFixed(2));
      balanceEl.textContent = `£${balance}`;
      prize = 0;
      prizeEl.textContent = formatCurrency(prize);
    }
  }

      function monsterFeedback(type) {
        const img = document.getElementById('monsterSprite');
        if (!img) return;
        if (type === 'damage') {
          img.classList.remove('healTint');
          img.classList.add('damageTint');
          img.classList.add('shake');
          setTimeout(() => { img.classList.remove('shake'); img.classList.remove('damageTint'); }, 380);
        } else if (type === 'heal') {
          img.classList.add('healTint');
          setTimeout(() => img.classList.remove('healTint'), 520);
        }
      }

      // Spawn a green healing ring for a given player's avatar (self or remote)
      function spawnHeartRingForPlayer(id, fromName) {
        try {
          const entry = lobbyPlayers.get(id);
          const gameEl = document.getElementById('game');
          const effectsEl = document.getElementById('effects');
          if (!entry || !entry.el || !gameEl || !effectsEl) return;
          const rectEl = entry.el.querySelector('#playerRect') || entry.el.querySelector('.playerRect');
          if (!rectEl) return;
          const rect = rectEl.getBoundingClientRect();
          const gameRect = gameEl.getBoundingClientRect();
          const cx = rect.left - gameRect.left + rect.width / 2;
          const cy = rect.top - gameRect.top + rect.height / 2;
          const p = document.createElement('div');
          p.className = 'particle';
          p.style.position = 'absolute';
          p.style.left = cx + 'px';
          p.style.top = cy + 'px';
          p.style.pointerEvents = 'none';
          p.style.willChange = 'transform, opacity';
          const size = Math.max(rect.width, rect.height) * 1.2;
          p.style.width = size + 'px';
          p.style.height = size + 'px';
          p.style.border = '3px solid #22c55e';
          p.style.borderRadius = '50%';
          p.style.background = 'transparent';
          (effectsEl).appendChild(p);
          try {
            const anim = p.animate([
              { transform: 'translate(-50%, -50%) scale(0.8)', opacity: 0.9 },
              { transform: 'translate(-50%, -50%) scale(2.4)', opacity: 0 }
            ], { duration: 750, easing: 'ease-out', fill: 'forwards' });
            anim.finished.then(()=> p.remove()).catch(()=> p.remove());
          } catch {
            p.style.transition = 'transform 750ms ease-out, opacity 750ms ease-out';
            requestAnimationFrame(()=>{
              p.style.transform = 'translate(-50%, -50%) scale(2.4)';
              p.style.opacity = '0';
              setTimeout(()=> p.remove(), 780);
            });
          }
        } catch {}
      }
      // Removed simulated notification popups for healing and prizes. Now only show for real network events.

      // Particle effects per suit — emitted from PLAYER rectangle
      function spawnCardParticlesFromPlayer(suit) {
        const gameEl = document.getElementById('game');
        const effectsEl = document.getElementById('effects');
        const playerRectEl = document.getElementById('playerRect');
        const prizeMetric = document.querySelector('#prize .value');
        if (!gameEl || !effectsEl || !playerRectEl) return;
        const rect = playerRectEl.getBoundingClientRect();
        const gameRect = gameEl.getBoundingClientRect();
        const originX = rect.left - gameRect.left + rect.width / 2;
        const originY = rect.top - gameRect.top + 2; // just above player's top
        const targetXTop = gameRect.width / 2; // top center horizontally (default)
        const targetYTop = 8; // near the top edge
        const count = suit === 'diamond' ? 14 : suit === 'heart' ? 1 : 12;
        for (let i = 0; i < count; i++) {
          const p = document.createElement('div');
          p.className = 'particle';
          p.style.position = 'absolute';
          p.style.left = originX + 'px';
          p.style.top = originY + 'px';
          p.style.pointerEvents = 'none';
          p.style.willChange = 'transform, opacity';
          let keyframes, duration, easing;
          switch (suit) {
            case 'spade': {
              // Pink circles that arc towards the top center
              const dx = (targetXTop - originX) * (0.85 + Math.random() * 0.25);
              const dy = (originY - targetYTop) * (0.9 + Math.random() * 0.2);
              const size = 6 + Math.random() * 6;
              p.style.width = size + 'px';
              p.style.height = size + 'px';
              p.style.borderRadius = '50%';
              p.style.background = '#ff4d9d';
              keyframes = [
                { transform: 'translate(0, 0)', opacity: 1 },
                { transform: `translate(${dx}px, -${dy}px)`, opacity: 0 }
              ];
              duration = 600 + Math.random() * 300;
              easing = 'ease-out';
              break;
            }
            case 'diamond': {
              // Gold coins that float down to the Prize amount
              // Determine target near the prize value element (fallback to bottom center if not found)
              let targetX = targetXTop;
              let targetY = gameRect.height - 24; // near bottom as fallback
              if (prizeMetric) {
                const prizeRect = prizeMetric.getBoundingClientRect();
                targetX = prizeRect.left - gameRect.left + prizeRect.width / 2;
                targetY = prizeRect.top - gameRect.top + prizeRect.height / 2;
              }
              // Coin appearance
              const size = 12 + Math.random() * 6;
              p.style.width = size + 'px';
              p.style.height = size + 'px';
              p.style.borderRadius = '50%';
              p.style.background = 'radial-gradient(circle at 35% 35%, #ffe08a 0%, #facc15 55%, #d97706 100%)';
              p.style.boxShadow = '0 0 8px rgba(250, 204, 21, 0.8)';
              // Gentle drift downward to the prize
              const dx = (targetX - originX) * (0.9 + Math.random() * 0.2);
              const dy = (targetY - originY) * (0.85 + Math.random() * 0.3);
              keyframes = [
                { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                { transform: `translate(${dx * 0.5}px, ${dy * 0.5}px) scale(1.05)`, opacity: 0.95 },
                { transform: `translate(${dx}px, ${dy}px) scale(0.98)`, opacity: 0 }
              ];
              duration = 900 + Math.random() * 400;
              easing = 'ease-in-out';
              break;
            }
            case 'heart': {
              // Green healing ring expanding from the player's center
              const cx = rect.left - gameRect.left + rect.width / 2;
              const cy = rect.top - gameRect.top + rect.height / 2;
              p.style.left = cx + 'px';
              p.style.top = cy + 'px';
              const size = Math.max(rect.width, rect.height) * 1.2;
              p.style.width = size + 'px';
              p.style.height = size + 'px';
              p.style.border = '3px solid #22c55e';
              p.style.borderRadius = '50%';
              p.style.background = 'transparent';
              keyframes = [
                { transform: 'translate(-50%, -50%) scale(0.8)', opacity: 0.9 },
                { transform: 'translate(-50%, -50%) scale(2.4)', opacity: 0 }
              ];
              duration = 750;
              easing = 'ease-out';
              break;
            }
            case 'club':
            default: {
              // White curls moving in a sine-like path to top center
              const dy = (originY - targetYTop);
              const amp = 14 + Math.random() * 8;
              const size = 5 + Math.random() * 4;
              p.style.width = size + 'px';
              p.style.height = size + 'px';
              p.style.borderRadius = '50%';
              p.style.background = '#ffffff';
              keyframes = [
                { transform: 'translate(0, 0)', opacity: 1 },
                { transform: `translate(${(targetXTop-originX)*0.25 + amp}px, -${dy * 0.25}px)`, opacity: 0.95 },
                { transform: `translate(${(targetXTop-originX)*0.5 - amp}px, -${dy * 0.5}px)`, opacity: 0.8 },
                { transform: `translate(${(targetXTop-originX)*0.75 + amp}px, -${dy * 0.75}px)`, opacity: 0.6 },
                { transform: `translate(${(targetXTop-originX)}px, -${dy}px)`, opacity: 0 }
              ];
              duration = 900 + Math.random() * 300;
              easing = 'ease-in-out';
              break;
            }
          }
          effectsEl.appendChild(p);
          try {
            const anim = p.animate(keyframes, { duration, easing, fill: 'forwards' });
            anim.finished.then(() => p.remove()).catch(() => p.remove());
          } catch {
            // Fallback via CSS transition if WAAPI is unsupported
            p.style.transition = `transform ${duration}ms ${easing}, opacity ${duration}ms ${easing}`;
            // Apply final frame
            const last = keyframes[keyframes.length - 1];
            requestAnimationFrame(() => {
              p.style.transform = last.transform || '';
              p.style.opacity = last.opacity != null ? String(last.opacity) : '0';
              setTimeout(() => p.remove(), duration + 20);
            });
          }
        }
      }

      // Spawn particles from a specific player's avatar by id (e.g., remote player's damage)
      function spawnParticlesFromPlayerById(id, suit){
        try {
          const entry = lobbyPlayers.get(id);
          const gameEl = document.getElementById('game');
          const effectsEl = document.getElementById('effects');
          if (!entry || !entry.el || !gameEl || !effectsEl) return;
          const rectEl = entry.el.querySelector('#playerRect') || entry.el.querySelector('.playerRect');
          const prizeMetric = document.querySelector('#prize .value');
          if (!rectEl) return;
          const rect = rectEl.getBoundingClientRect();
          const gameRect = gameEl.getBoundingClientRect();
          const originX = rect.left - gameRect.left + rect.width / 2;
          const originY = rect.top - gameRect.top + 2;
          const targetXTop = gameRect.width / 2;
          const targetYTop = 8;
          const count = suit === 'diamond' ? 14 : suit === 'heart' ? 1 : 12;
          for (let i = 0; i < count; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.position = 'absolute';
            p.style.left = originX + 'px';
            p.style.top = originY + 'px';
            p.style.pointerEvents = 'none';
            p.style.willChange = 'transform, opacity';
            let keyframes, duration, easing;
            switch (suit) {
              case 'spade': {
                const dx = (targetXTop - originX) * (0.85 + Math.random() * 0.25);
                const dy = (originY - targetYTop) * (0.9 + Math.random() * 0.2);
                const size = 6 + Math.random() * 6;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                p.style.borderRadius = '50%';
                p.style.background = '#ff4d9d';
                keyframes = [
                  { transform: 'translate(0, 0)', opacity: 1 },
                  { transform: `translate(${dx}px, -${dy}px)`, opacity: 0 }
                ];
                duration = 600 + Math.random() * 300;
                easing = 'ease-out';
                break;
              }
              case 'diamond': {
                let targetX = targetXTop;
                let targetY = gameRect.height - 24;
                if (prizeMetric) {
                  const prizeRect = prizeMetric.getBoundingClientRect();
                  targetX = prizeRect.left - gameRect.left + prizeRect.width / 2;
                  targetY = prizeRect.top - gameRect.top + prizeRect.height / 2;
                }
                const size = 12 + Math.random() * 6;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                p.style.borderRadius = '50%';
                p.style.background = 'radial-gradient(circle at 35% 35%, #ffe08a 0%, #facc15 55%, #d97706 100%)';
                p.style.boxShadow = '0 0 8px rgba(250, 204, 21, 0.8)';
                const dx = (targetX - originX) * (0.9 + Math.random() * 0.2);
                const dy = (targetY - originY) * (0.85 + Math.random() * 0.3);
                keyframes = [
                  { transform: 'translate(0, 0) scale(1)', opacity: 1 },
                  { transform: `translate(${dx * 0.5}px, ${dy * 0.5}px) scale(1.05)`, opacity: 0.95 },
                  { transform: `translate(${dx}px, ${dy}px) scale(0.98)`, opacity: 0 }
                ];
                duration = 900 + Math.random() * 400;
                easing = 'ease-in-out';
                break;
              }
              case 'heart': {
                const cx = rect.left - gameRect.left + rect.width / 2;
                const cy = rect.top - gameRect.top + rect.height / 2;
                p.style.left = cx + 'px';
                p.style.top = cy + 'px';
                const size = Math.max(rect.width, rect.height) * 1.2;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                p.style.border = '3px solid #22c55e';
                p.style.borderRadius = '50%';
                p.style.background = 'transparent';
                keyframes = [
                  { transform: 'translate(-50%, -50%) scale(0.8)', opacity: 0.9 },
                  { transform: 'translate(-50%, -50%) scale(2.4)', opacity: 0 }
                ];
                duration = 750;
                easing = 'ease-out';
                break;
              }
              case 'club':
              default: {
                const dy = (originY - targetYTop);
                const amp = 14 + Math.random() * 8;
                const size = 5 + Math.random() * 4;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                p.style.borderRadius = '50%';
                p.style.background = '#ffffff';
                keyframes = [
                  { transform: 'translate(0, 0)', opacity: 1 },
                  { transform: `translate(${(targetXTop-originX)*0.25 + amp}px, -${dy * 0.25}px)`, opacity: 0.95 },
                  { transform: `translate(${(targetXTop-originX)*0.5 - amp}px, -${dy * 0.5}px)`, opacity: 0.8 },
                  { transform: `translate(${(targetXTop-originX)*0.75 + amp}px, -${dy * 0.75}px)`, opacity: 0.6 },
                  { transform: `translate(${(targetXTop-originX)}px, -${dy}px)`, opacity: 0 }
                ];
                duration = 900 + Math.random() * 300;
                easing = 'ease-in-out';
                break;
              }
            }
            effectsEl.appendChild(p);
            try {
              const anim = p.animate(keyframes, { duration, easing, fill: 'forwards' });
              anim.finished.then(() => p.remove()).catch(() => p.remove());
            } catch {
              p.style.transition = `transform ${duration}ms ${easing}, opacity ${duration}ms ${easing}`;
              const last = keyframes[keyframes.length - 1];
              requestAnimationFrame(() => {
                p.style.transform = last.transform || '';
                p.style.opacity = last.opacity != null ? String(last.opacity) : '0';
                setTimeout(() => p.remove(), duration + 20);
              });
            }
          }
        } catch {}
      }
    </script>
  </body>
</html>
